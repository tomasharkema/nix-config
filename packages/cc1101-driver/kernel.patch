diff --git a/Makefile b/Makefile
index c3154cc..0a9a3fb 100755
--- a/Makefile
+++ b/Makefile
@@ -1,11 +1,16 @@
 obj-m := cc1101.o
 cc1101-objs+= cc1101_main.o cc1101_chrdev.o cc1101_spi.o cc1101_radio.o cc1101_config.o
 
+KDIR ?= "/nix/store/hfgrxxhrzax6n0yp33rxsjq7vzs5w86w-linux-6.14.5-dev/lib/modules/6.14.5/build"
+
 all:
-	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+	make -C $(KDIR) M=$(PWD) modules
 
 rxonly:
-	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) ccflags-y="-DRXONLY" modules
+	make -C $(KDIR) M=$(PWD) ccflags-y="-DRXONLY" modules
 
 clean:
-	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
\ No newline at end of file
+	make -C $(KDIR) M=$(PWD) clean
+
+install:
+	make -C $(KDIR) M=$(PWD) modules_install
diff --git a/cc1101_chrdev.c b/cc1101_chrdev.c
index ef42cf0..e4960fd 100644
--- a/cc1101_chrdev.c
+++ b/cc1101_chrdev.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
-* Copyright (c) 2021
-*/
+ * Copyright (c) 2021
+ */
 #include <linux/cdev.h>
 #include <linux/uaccess.h>
 
@@ -43,423 +43,454 @@ extern uint max_packet_size;
 extern uint rx_fifo_size;
 
 static struct class *dev_class;
-cc1101_t* device_list[N_SPI_MINOR_NUMBERS] = {0};
+cc1101_t *device_list[N_SPI_MINOR_NUMBERS] = {0};
 static DEFINE_MUTEX(device_list_lock);
 
 /*
-* Handler for open events to /dev/cc1101.x.x
-* Only one handle is allowed to transmit, receive or configure the device at a time
-* Operations will block until /dev/cc1101.x.x is closed
-*/
+ * Handler for open events to /dev/cc1101.x.x
+ * Only one handle is allowed to transmit, receive or configure the device at a time
+ * Operations will block until /dev/cc1101.x.x is closed
+ */
 static int chrdev_open(struct inode *inode, struct file *file)
 {
-    cc1101_t* cc1101 = NULL;
-    int device_index;
-
-    // Search the device list for the cc1101 struct relating to the chardev
-    if(mutex_lock_interruptible(&device_list_lock) != 0) {
-        return -EBUSY;
-    }
-
-    for(device_index = 0; device_index < N_SPI_MINOR_NUMBERS; device_index++){
-        if (device_list[device_index] != NULL){
-            if (inode->i_rdev == device_list[device_index]->devt) {
-                cc1101 = device_list[device_index];
-            }
-        }
+  cc1101_t *cc1101 = NULL;
+  int device_index;
+
+  // Search the device list for the cc1101 struct relating to the chardev
+  if (mutex_lock_interruptible(&device_list_lock) != 0)
+  {
+    return -EBUSY;
+  }
+
+  for (device_index = 0; device_index < N_SPI_MINOR_NUMBERS; device_index++)
+  {
+    if (device_list[device_index] != NULL)
+    {
+      if (inode->i_rdev == device_list[device_index]->devt)
+      {
+        cc1101 = device_list[device_index];
+      }
     }
+  }
 
-	mutex_unlock(&device_list_lock);
+  mutex_unlock(&device_list_lock);
 
-    // This should never occur - a chardev shouldn't be created without a CC1101 being present
-    if(cc1101 == NULL){
-        return -ENODEV;
-    }
+  // This should never occur - a chardev shouldn't be created without a CC1101 being present
+  if (cc1101 == NULL)
+  {
+    return -ENODEV;
+  }
 
-    // Once found, lock the device and save the pointer to private data for the subsequent functions
-    if(mutex_lock_interruptible(&cc1101->chrdev_lock) != 0) {
-        return -EBUSY;
-    };
+  // Once found, lock the device and save the pointer to private data for the subsequent functions
+  if (mutex_lock_interruptible(&cc1101->chrdev_lock) != 0)
+  {
+    return -EBUSY;
+  };
 
-    file->private_data = cc1101;
-    return 0;
+  file->private_data = cc1101;
+  return 0;
 }
 
 /*
-* Handler for close events to /dev/cc1101.x.x
-* Releases the device lock obtained at open
-*/
+ * Handler for close events to /dev/cc1101.x.x
+ * Releases the device lock obtained at open
+ */
 static int chrdev_release(struct inode *inode, struct file *file)
 {
-    cc1101_t* cc1101 = file->private_data;
-    mutex_unlock(&cc1101->chrdev_lock);
-    file->private_data = NULL;
-    return 0;
+  cc1101_t *cc1101 = file->private_data;
+  mutex_unlock(&cc1101->chrdev_lock);
+  file->private_data = NULL;
+  return 0;
 }
 
 /*
-* Handler for iotcl commands to /dev/cc1101.x.x
-* IOCTLs can be used to set and get the TX and RX config, reset the device
-* and retrieve the contents of the CC1101's registers
-*/
+ * Handler for iotcl commands to /dev/cc1101.x.x
+ * IOCTLs can be used to set and get the TX and RX config, reset the device
+ * and retrieve the contents of the CC1101's registers
+ */
 static long chrdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-    cc1101_t* cc1101 = file->private_data;
-    spi_transaction_t rssi;
-    int version = DRIVER_VERSION;
-    int ret = 0;
+  cc1101_t *cc1101 = file->private_data;
+  spi_transaction_t rssi;
+  int version = DRIVER_VERSION;
+  int ret = 0;
 
-    // Temporary holding variables for new TX and RX configs
-    cc1101_device_config_t device_config;
+  // Temporary holding variables for new TX and RX configs
+  cc1101_device_config_t device_config;
 #ifndef RXONLY
-    struct cc1101_tx_config tx_config;
+  struct cc1101_tx_config tx_config;
 #endif
-    struct cc1101_rx_config rx_config;
+  struct cc1101_rx_config rx_config;
+
+  if (_IOC_TYPE(cmd) != CC1101_BASE)
+  {
+    CC1101_ERROR(cc1101, "Invalid IOCTL\n");
+    return -EIO;
+  }
+
+  // Lock the device for reconfiguration
+  if (mutex_lock_interruptible(&cc1101->device_lock) != 0)
+  {
+    return -EBUSY;
+  };
+
+  switch (cmd)
+  {
+
+  // Get the userspace API version
+  case CC1101_GET_VERSION:
+    ret = copy_to_user((unsigned char *)arg, &version, sizeof(version));
+    break;
+
+  // Reset the device and driver state
+  case CC1101_RESET:
+    CC1101_INFO(cc1101, "Reset");
+    cc1101_reset(cc1101);
+    ret = 0;
+    break;
+
+  // Set the RX config for the device
+  case CC1101_SET_RX_CONF:
+
+    // Copy the config provided in userspace to the kernel
+    if (copy_from_user(&rx_config, (unsigned char *)arg, sizeof(rx_config)) != 0)
+    {
+      CC1101_ERROR(cc1101, "Error Copying Device RX Config\n");
+      ret = -EFAULT;
+      goto done;
+    }
+
+    // Validate the provided config
+    if (!cc1101_config_validate_rx(cc1101, &rx_config))
+    {
+      ret = -EINVAL;
+      goto done;
+    }
 
-    if(_IOC_TYPE(cmd) != CC1101_BASE){
-        CC1101_ERROR(cc1101, "Invalid IOCTL\n");
-        return -EIO;
+    // Replace the RX FIFO with a new one based on the provided packet size and the maximum number of queued packets
+    kfifo_free(&cc1101->rx_fifo);
+    if (kfifo_alloc(&cc1101->rx_fifo, rx_config.packet_length * rx_fifo_size, GFP_KERNEL) != 0)
+    {
+      CC1101_ERROR(cc1101, "Failed to allocate packet FIFO memory");
+      ret = -ENOMEM;
+      goto done;
     }
 
-    // Lock the device for reconfiguration
-    if(mutex_lock_interruptible(&cc1101->device_lock) != 0) {
-        return -EBUSY;
-    };
-
-    switch(cmd){
-
-        // Get the userspace API version
-        case CC1101_GET_VERSION:
-            ret = copy_to_user((unsigned char*) arg, &version, sizeof(version));
-            break;
-
-        // Reset the device and driver state
-        case CC1101_RESET:
-            CC1101_INFO(cc1101, "Reset");
-            cc1101_reset(cc1101);
-            ret = 0;
-            break;
-
-        // Set the RX config for the device
-        case CC1101_SET_RX_CONF:
-
-            // Copy the config provided in userspace to the kernel
-            if(copy_from_user(&rx_config, (unsigned char*) arg, sizeof(rx_config)) != 0){
-                CC1101_ERROR(cc1101, "Error Copying Device RX Config\n");
-                ret = -EFAULT;
-                goto done;
-            }
-
-            // Validate the provided config
-            if(!cc1101_config_validate_rx(cc1101, &rx_config)){
-                ret = -EINVAL;
-                goto done;
-            }
-
-            // Replace the RX FIFO with a new one based on the provided packet size and the maximum number of queued packets
-            kfifo_free(&cc1101->rx_fifo);
-            if(kfifo_alloc(&cc1101->rx_fifo, rx_config.packet_length * rx_fifo_size, GFP_KERNEL) != 0) {
-                CC1101_ERROR(cc1101, "Failed to allocate packet FIFO memory");
-                ret = -ENOMEM;
-                goto done;
-            }
-
-            // Store the new RX config in the device struct
-            memcpy(&cc1101->rx_config, &rx_config, sizeof(struct cc1101_rx_config));
-
-            // Set the device to idle before reconfiguring
-            cc1101_idle(cc1101);
-
-            // Write the configuration to the device
-            cc1101_config_apply_rx(cc1101);
-
-            // Enter RX mode on the device
-            cc1101_rx(cc1101);
-
-            ret = 0;
-            break;
-
-        // Returns the RX config configured in the driver to userspace
-        case CC1101_GET_RX_CONF:
-            ret = copy_to_user((unsigned char*) arg, &cc1101->rx_config, sizeof(struct cc1101_rx_config));
-            break;
-
-        // Returns the register values for the RX configuration to userspace
-        case CC1101_GET_RX_RAW_CONF:
-            cc1101_config_rx_to_registers(device_config, &cc1101->rx_config);
-            ret = copy_to_user((unsigned char*) arg, device_config, sizeof(device_config));
-            break;
-
-        // Set the TX config to use for the next packet written to /dev/cc1101.x.x
-        case CC1101_SET_TX_CONF:
+    // Store the new RX config in the device struct
+    memcpy(&cc1101->rx_config, &rx_config, sizeof(struct cc1101_rx_config));
+
+    // Set the device to idle before reconfiguring
+    cc1101_idle(cc1101);
+
+    // Write the configuration to the device
+    cc1101_config_apply_rx(cc1101);
+
+    // Enter RX mode on the device
+    cc1101_rx(cc1101);
+
+    ret = 0;
+    break;
+
+  // Returns the RX config configured in the driver to userspace
+  case CC1101_GET_RX_CONF:
+    ret = copy_to_user((unsigned char *)arg, &cc1101->rx_config, sizeof(struct cc1101_rx_config));
+    break;
+
+  // Returns the register values for the RX configuration to userspace
+  case CC1101_GET_RX_RAW_CONF:
+    cc1101_config_rx_to_registers(device_config, &cc1101->rx_config);
+    ret = copy_to_user((unsigned char *)arg, device_config, sizeof(device_config));
+    break;
+
+  // Set the TX config to use for the next packet written to /dev/cc1101.x.x
+  case CC1101_SET_TX_CONF:
 #ifndef RXONLY
-            // Copy the config provided in userspace to the kernel
-            if(copy_from_user(&tx_config, (unsigned char*) arg, sizeof(tx_config)) != 0){
-                CC1101_ERROR(cc1101, "Error Copying Device TX Config\n");
-                ret = -EFAULT;
-                goto done;
-            }
-
-            // Validate the provided config
-            if(!cc1101_config_validate_tx(cc1101, &tx_config)){
-                ret = -EINVAL;
-                goto done;
-            }
-
-            // Store the new TX config in the device struct
-            memcpy(&cc1101->tx_config, &tx_config, sizeof(struct cc1101_tx_config));
-
-            ret = 0;
+    // Copy the config provided in userspace to the kernel
+    if (copy_from_user(&tx_config, (unsigned char *)arg, sizeof(tx_config)) != 0)
+    {
+      CC1101_ERROR(cc1101, "Error Copying Device TX Config\n");
+      ret = -EFAULT;
+      goto done;
+    }
+
+    // Validate the provided config
+    if (!cc1101_config_validate_tx(cc1101, &tx_config))
+    {
+      ret = -EINVAL;
+      goto done;
+    }
+
+    // Store the new TX config in the device struct
+    memcpy(&cc1101->tx_config, &tx_config, sizeof(struct cc1101_tx_config));
+
+    ret = 0;
 #else
-            ret = -EPERM;
+    ret = -EPERM;
 #endif
-            break;
+    break;
 
-        // Returns the TX config configured in the driver to userspace
-        case CC1101_GET_TX_CONF:
+  // Returns the TX config configured in the driver to userspace
+  case CC1101_GET_TX_CONF:
 #ifndef RXONLY
-            ret = copy_to_user((unsigned char*) arg, &cc1101->tx_config, sizeof(struct cc1101_tx_config));
+    ret = copy_to_user((unsigned char *)arg, &cc1101->tx_config, sizeof(struct cc1101_tx_config));
 #else
-            ret = -EPERM;
+    ret = -EPERM;
 #endif
-            break;
+    break;
 
-        // Returns the register values for the TX configuration to userspace
-        case CC1101_GET_TX_RAW_CONF:
+  // Returns the register values for the TX configuration to userspace
+  case CC1101_GET_TX_RAW_CONF:
 #ifndef RXONLY
-            cc1101_config_tx_to_registers(device_config, &cc1101->tx_config);
-            ret = copy_to_user((unsigned char*) arg, device_config, sizeof(device_config));
+    cc1101_config_tx_to_registers(device_config, &cc1101->tx_config);
+    ret = copy_to_user((unsigned char *)arg, device_config, sizeof(device_config));
 #else
-            ret = -EPERM;
+    ret = -EPERM;
 #endif
-            break;
-
-        // Reads the current state of the CC1101's registers and returns them to userspace
-        case CC1101_GET_DEV_RAW_CONF:
-            cc1101_spi_read_config_registers(cc1101, device_config, sizeof(device_config));
-            ret = copy_to_user((unsigned char*) arg, device_config, sizeof(device_config));
-            break;
-
-        case CC1101_GET_RSSI:
-            rssi = cc1101_spi_read_status_register_once(cc1101, RSSI);
-            ret = copy_to_user((unsigned char*) arg, &rssi.data, sizeof(rssi.data));
-            break;
-
-        case CC1101_GET_MAX_PACKET_SIZE:
-            ret = copy_to_user((unsigned char*) arg, &max_packet_size, sizeof(max_packet_size));
-            break;
-
-        default:
-            CC1101_ERROR(cc1101, "Unknown Command %d, %zu, %zu\n", cmd, sizeof(struct cc1101_rx_config), sizeof(struct cc1101_tx_config));
-            ret = -EIO;
-            break;
-    }
+    break;
+
+  // Reads the current state of the CC1101's registers and returns them to userspace
+  case CC1101_GET_DEV_RAW_CONF:
+    cc1101_spi_read_config_registers(cc1101, device_config, sizeof(device_config));
+    ret = copy_to_user((unsigned char *)arg, device_config, sizeof(device_config));
+    break;
+
+  case CC1101_GET_RSSI:
+    rssi = cc1101_spi_read_status_register_once(cc1101, RSSI);
+    ret = copy_to_user((unsigned char *)arg, &rssi.data, sizeof(rssi.data));
+    break;
+
+  case CC1101_GET_MAX_PACKET_SIZE:
+    ret = copy_to_user((unsigned char *)arg, &max_packet_size, sizeof(max_packet_size));
+    break;
+
+  default:
+    CC1101_ERROR(cc1101, "Unknown Command %d, %zu, %zu\n", cmd, sizeof(struct cc1101_rx_config), sizeof(struct cc1101_tx_config));
+    ret = -EIO;
+    break;
+  }
 
 done:
-    mutex_unlock(&cc1101->device_lock);
-    return ret;
+  mutex_unlock(&cc1101->device_lock);
+  return ret;
 }
 
 /*
-* Handler for read events to /dev/cc1101.x.x
-* A read request will return one packet from the receive buffer, if present
-*/
+ * Handler for read events to /dev/cc1101.x.x
+ * A read request will return one packet from the receive buffer, if present
+ */
 static ssize_t chrdev_read(struct file *file, char __user *buf, size_t len, loff_t *off)
 {
-    cc1101_t* cc1101 = file->private_data;
-    ssize_t ret;
-    unsigned int out_bytes;
-
-    // Check a RX config has been set and that the out buffer is the correct size
-    if (cc1101->rx_config.packet_length == 0 || len != cc1101->rx_config.packet_length) {
-        return -EMSGSIZE;
-    }
-
-    if(mutex_lock_interruptible(&cc1101->device_lock) != 0) {
-        return -EBUSY;
-    };
-
-    // Check there is at least one packet in the RX FIFO
-    if (kfifo_len(&cc1101->rx_fifo) < cc1101->rx_config.packet_length) {
-        ret = -ENOMSG;
-        goto done;
-    }
-
-    // Copy the packet out to userspace
-    if (kfifo_to_user(&cc1101->rx_fifo, buf, len, &out_bytes) != 0) {
-        ret = -EFAULT;
-        goto done;
-    }
-
-    // Check the number of bytes copied out matches the expected number
-    if (out_bytes == cc1101->rx_config.packet_length) {
-        ret = out_bytes;
-    }
-    else {
-        ret = -EFAULT;
-    }
+  cc1101_t *cc1101 = file->private_data;
+  ssize_t ret;
+  unsigned int out_bytes;
+
+  // Check a RX config has been set and that the out buffer is the correct size
+  if (cc1101->rx_config.packet_length == 0 || len != cc1101->rx_config.packet_length)
+  {
+    return -EMSGSIZE;
+  }
+
+  if (mutex_lock_interruptible(&cc1101->device_lock) != 0)
+  {
+    return -EBUSY;
+  };
+
+  // Check there is at least one packet in the RX FIFO
+  if (kfifo_len(&cc1101->rx_fifo) < cc1101->rx_config.packet_length)
+  {
+    ret = -ENOMSG;
+    goto done;
+  }
+
+  // Copy the packet out to userspace
+  if (kfifo_to_user(&cc1101->rx_fifo, buf, len, &out_bytes) != 0)
+  {
+    ret = -EFAULT;
+    goto done;
+  }
+
+  // Check the number of bytes copied out matches the expected number
+  if (out_bytes == cc1101->rx_config.packet_length)
+  {
+    ret = out_bytes;
+  }
+  else
+  {
+    ret = -EFAULT;
+  }
 
 done:
-    mutex_unlock(&cc1101->device_lock);
-    return ret;
+  mutex_unlock(&cc1101->device_lock);
+  return ret;
 }
 
 /*
-* Handler for write events to /dev/cc1101.x.x
-* Written bytes are transmitted by the CC1101 according the TX config
-*/
+ * Handler for write events to /dev/cc1101.x.x
+ * Written bytes are transmitted by the CC1101 according the TX config
+ */
 static ssize_t chrdev_write(struct file *file, const char __user *buf, size_t len, loff_t *off)
 {
 #ifndef RXONLY
-    cc1101_t* cc1101 = file->private_data;
-    ssize_t ret;
-    unsigned char *tx_bytes;
-
-
-    // Check the number of bytes to be transmitted are allowed
-    if (len > max_packet_size) {
-        ret = -EMSGSIZE;
-        goto done;
-    }
-
-    // Allocate a temporary buffer for the bytes to be transmitted
-    tx_bytes = kmalloc(len, GFP_KERNEL);
-    if(tx_bytes == NULL) {
-        ret = -ENOMEM;
-        goto done;
-    }
-
-    // Copy from userspace to temporary buffer in kernel space
-    if(copy_from_user(tx_bytes, buf, len) != 0) {
-        ret = -EFAULT;
-        goto err_copy;
-    }
-
-    // Lock the device for reconfiguration
-    if(mutex_lock_interruptible(&cc1101->device_lock) != 0) {
-        ret = -EBUSY;
-        goto err_lock;
-    };
-
-    // Set the device to idle before configuring
-    cc1101_idle(cc1101);
-
-    // Apply the TX config
-    cc1101_config_apply_tx(cc1101);
-
-    // Transmit bytes using the device and return the number of transmitted bytes
-    cc1101_tx(cc1101, tx_bytes, len);
-    ret = len;
-
-    mutex_unlock(&cc1101->device_lock);
+  cc1101_t *cc1101 = file->private_data;
+  ssize_t ret;
+  unsigned char *tx_bytes;
+
+  // Check the number of bytes to be transmitted are allowed
+  if (len > max_packet_size)
+  {
+    ret = -EMSGSIZE;
+    goto done;
+  }
+
+  // Allocate a temporary buffer for the bytes to be transmitted
+  tx_bytes = kmalloc(len, GFP_KERNEL);
+  if (tx_bytes == NULL)
+  {
+    ret = -ENOMEM;
+    goto done;
+  }
+
+  // Copy from userspace to temporary buffer in kernel space
+  if (copy_from_user(tx_bytes, buf, len) != 0)
+  {
+    ret = -EFAULT;
+    goto err_copy;
+  }
+
+  // Lock the device for reconfiguration
+  if (mutex_lock_interruptible(&cc1101->device_lock) != 0)
+  {
+    ret = -EBUSY;
+    goto err_lock;
+  };
+
+  // Set the device to idle before configuring
+  cc1101_idle(cc1101);
+
+  // Apply the TX config
+  cc1101_config_apply_tx(cc1101);
+
+  // Transmit bytes using the device and return the number of transmitted bytes
+  cc1101_tx(cc1101, tx_bytes, len);
+  ret = len;
+
+  mutex_unlock(&cc1101->device_lock);
 err_lock:
 err_copy:
-    kfree(tx_bytes);
+  kfree(tx_bytes);
 done:
-    return ret;
+  return ret;
 #else
-    return -EPERM;
+  return -EPERM;
 #endif
 }
 
 /*
-*   Add a character device for a cc1101
-*/
-int cc1101_chrdev_add_device(cc1101_t * cc1101) {
-    int ret;
-    int device_index;
-
-    mutex_lock(&device_list_lock);
-
-    // Search for a free minor number
-    for(device_index = 0; device_index < N_SPI_MINOR_NUMBERS; device_index++){
-        if(device_list[device_index] == NULL){
-            // Allocate the minor number
-            cc1101->devt = MKDEV(SPI_MAJOR_NUMBER, device_index);
-
-            // Create a /dev/cc1101.x.x character device
-            if(IS_ERR(device_create(dev_class, &cc1101->spi->dev, cc1101->devt, cc1101, "cc1101.%d.%d", cc1101->spi->master->bus_num, cc1101->spi->chip_select))) {
-                ret = -ENODEV;
-                goto done;
-            }
-
-            // Insert the device in the device list
-            device_list[device_index] = cc1101;
-            ret = 0;
-            goto done;
-        }
+ *   Add a character device for a cc1101
+ */
+int cc1101_chrdev_add_device(cc1101_t *cc1101)
+{
+  int ret;
+  int device_index;
+
+  mutex_lock(&device_list_lock);
+
+  // Search for a free minor number
+  for (device_index = 0; device_index < N_SPI_MINOR_NUMBERS; device_index++)
+  {
+    if (device_list[device_index] == NULL)
+    {
+      // Allocate the minor number
+      cc1101->devt = MKDEV(SPI_MAJOR_NUMBER, device_index);
+
+      // Create a /dev/cc1101.x.x character device
+      if (IS_ERR(device_create(dev_class, &cc1101->spi->dev, cc1101->devt, cc1101, "cc1101.%d.%d", cc1101->spi->controller->bus_num, cc1101->spi->chip_select)))
+      {
+        ret = -ENODEV;
+        goto done;
+      }
+
+      // Insert the device in the device list
+      device_list[device_index] = cc1101;
+      ret = 0;
+      goto done;
     }
-    ret = -ENODEV;
+  }
+  ret = -ENODEV;
 
 done:
-    mutex_unlock(&device_list_lock);
-    return ret;
+  mutex_unlock(&device_list_lock);
+  return ret;
 }
 
 /*
-*   Remove a cc1101 character device
-*/
-void cc1101_chrdev_remove_device(cc1101_t * cc1101) {
-    mutex_lock(&device_list_lock);
+ *   Remove a cc1101 character device
+ */
+void cc1101_chrdev_remove_device(cc1101_t *cc1101)
+{
+  mutex_lock(&device_list_lock);
 
-    // Destroy the character device and remove the entry from the device list
-    device_destroy(dev_class, cc1101->devt);
-    device_list[MINOR(cc1101->devt)] = NULL;
+  // Destroy the character device and remove the entry from the device list
+  device_destroy(dev_class, cc1101->devt);
+  device_list[MINOR(cc1101->devt)] = NULL;
 
-    mutex_unlock(&device_list_lock);
+  mutex_unlock(&device_list_lock);
 }
 
 // Chardev operation functions
 static struct file_operations fops =
-{
-    .owner = THIS_MODULE,
-    .read = chrdev_read,
-    .write = chrdev_write,
-    .unlocked_ioctl = chrdev_ioctl,
-    .open = chrdev_open,
-    .release = chrdev_release,
+    {
+        .owner = THIS_MODULE,
+        .read = chrdev_read,
+        .write = chrdev_write,
+        .unlocked_ioctl = chrdev_ioctl,
+        .open = chrdev_open,
+        .release = chrdev_release,
 };
 
 /*
-*   Setup the CC1101 character device class
-*/
-int cc1101_chrdev_setup(struct spi_driver* cc1101_driver)
+ *   Setup the CC1101 character device class
+ */
+int cc1101_chrdev_setup(struct spi_driver *cc1101_driver)
 {
-	int ret;
-
-	ret = register_chrdev(SPI_MAJOR_NUMBER, "spi", &fops);
-	if (ret < 0) {
-        goto err_register;
-    }
-	// per https://github.com/28757B2/cc1101-driver/issues/8#issuecomment-2179558238
-	dev_class = class_create("cc1101");
-	if (IS_ERR(dev_class)) {
-		ret = PTR_ERR(dev_class);
-        goto err_class_create;
-	}
-
-	ret = spi_register_driver(cc1101_driver);
-	if (ret < 0) {
-        goto err_register_driver;
-	}
-
-	goto done;
+  int ret;
+
+  ret = register_chrdev(SPI_MAJOR_NUMBER, "spi", &fops);
+  if (ret < 0)
+  {
+    goto err_register;
+  }
+  // per https://github.com/28757B2/cc1101-driver/issues/8#issuecomment-2179558238
+  dev_class = class_create("cc1101");
+  if (IS_ERR(dev_class))
+  {
+    ret = PTR_ERR(dev_class);
+    goto err_class_create;
+  }
+
+  ret = spi_register_driver(cc1101_driver);
+  if (ret < 0)
+  {
+    goto err_register_driver;
+  }
+
+  goto done;
 
 err_register_driver:
-    class_destroy(dev_class);
+  class_destroy(dev_class);
 err_class_create:
-    unregister_chrdev(SPI_MAJOR_NUMBER, cc1101_driver->driver.name);
+  unregister_chrdev(SPI_MAJOR_NUMBER, cc1101_driver->driver.name);
 err_register:
 done:
-    return ret;
+  return ret;
 }
 
 /*
-*   Remove the CC1101 character device class
-*/
-void cc1101_chrdev_teardown(struct spi_driver* cc1101_driver)
+ *   Remove the CC1101 character device class
+ */
+void cc1101_chrdev_teardown(struct spi_driver *cc1101_driver)
 {
-    spi_unregister_driver(cc1101_driver);
-	class_destroy(dev_class);
-	unregister_chrdev(SPI_MAJOR_NUMBER, cc1101_driver->driver.name);
+  spi_unregister_driver(cc1101_driver);
+  class_destroy(dev_class);
+  unregister_chrdev(SPI_MAJOR_NUMBER, cc1101_driver->driver.name);
 }
diff --git a/cc1101_internal.h b/cc1101_internal.h
index ebaa64c..93241b8 100644
--- a/cc1101_internal.h
+++ b/cc1101_internal.h
@@ -1,12 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
-* Copyright (c) 2021
-*/
+ * Copyright (c) 2021
+ */
 #ifndef CC1101_INTERNAL_H
 #define CC1101_INTERNAL_H
 
 #include <linux/kernel.h>
 #include <linux/kfifo.h>
+#include <linux/timer.h>
 
 #include "cc1101.h"
 
@@ -14,138 +15,141 @@
 
 // Configuration Registers - CC1101 Datasheet Table 43
 // Generated in SmartRF Studio with config string #define @RN@ @<<@ 0x@AH@ @<<@ // @Rd@
-#define IOCFG2    0x00      // GDO2 Output Pin Configuration
-#define IOCFG1    0x01      // GDO1 Output Pin Configuration
-#define IOCFG0    0x02      // GDO0 Output Pin Configuration
-#define FIFOTHR   0x03      // RX FIFO and TX FIFO Thresholds
-#define SYNC1     0x04      // Sync Word, High Byte
-#define SYNC0     0x05      // Sync Word, Low Byte
-#define PKTLEN    0x06      // Packet Length
-#define PKTCTRL1  0x07      // Packet Automation Control
-#define PKTCTRL0  0x08      // Packet Automation Control
-#define ADDR      0x09      // Device Address
-#define CHANNR    0x0A      // Channel Number
-#define FSCTRL1   0x0B      // Frequency Synthesizer Control
-#define FSCTRL0   0x0C      // Frequency Synthesizer Control
-#define FREQ2     0x0D      // Frequency Control Word, High Byte
-#define FREQ1     0x0E      // Frequency Control Word, Middle Byte
-#define FREQ0     0x0F      // Frequency Control Word, Low Byte
-#define MDMCFG4   0x10      // Modem Configuration
-#define MDMCFG3   0x11      // Modem Configuration
-#define MDMCFG2   0x12      // Modem Configuration
-#define MDMCFG1   0x13      // Modem Configuration
-#define MDMCFG0   0x14      // Modem Configuration
-#define DEVIATN   0x15      // Modem Deviation Setting
-#define MCSM2     0x16      // Main Radio Control State Machine Configuration
-#define MCSM1     0x17      // Main Radio Control State Machine Configuration
-#define MCSM0     0x18      // Main Radio Control State Machine Configuration
-#define FOCCFG    0x19      // Frequency Offset Compensation Configuration
-#define BSCFG     0x1A      // Bit Synchronization Configuration
-#define AGCCTRL2  0x1B      // AGC Control
-#define AGCCTRL1  0x1C      // AGC Control
-#define AGCCTRL0  0x1D      // AGC Control
-#define WOREVT1   0x1E      // High Byte Event0 Timeout
-#define WOREVT0   0x1F      // Low Byte Event0 Timeout
-#define WORCTRL   0x20      // Wake On Radio Control
-#define FREND1    0x21      // Front End RX Configuration
-#define FREND0    0x22      // Front End TX Configuration
-#define FSCAL3    0x23      // Frequency Synthesizer Calibration
-#define FSCAL2    0x24      // Frequency Synthesizer Calibration
-#define FSCAL1    0x25      // Frequency Synthesizer Calibration
-#define FSCAL0    0x26      // Frequency Synthesizer Calibration
-#define RCCTRL1   0x27      // RC Oscillator Configuration
-#define RCCTRL0   0x28      // RC Oscillator Configuration
-#define FSTEST    0x29      // Frequency Synthesizer Calibration Control
-#define PTEST     0x2A      // Production Test
-#define AGCTEST   0x2B      // AGC Test
-#define TEST2     0x2C      // Various Test Settings
-#define TEST1     0x2D      // Various Test Settings
-#define TEST0     0x2E      // Various Test Settings
+#define IOCFG2 0x00   // GDO2 Output Pin Configuration
+#define IOCFG1 0x01   // GDO1 Output Pin Configuration
+#define IOCFG0 0x02   // GDO0 Output Pin Configuration
+#define FIFOTHR 0x03  // RX FIFO and TX FIFO Thresholds
+#define SYNC1 0x04    // Sync Word, High Byte
+#define SYNC0 0x05    // Sync Word, Low Byte
+#define PKTLEN 0x06   // Packet Length
+#define PKTCTRL1 0x07 // Packet Automation Control
+#define PKTCTRL0 0x08 // Packet Automation Control
+#define ADDR 0x09     // Device Address
+#define CHANNR 0x0A   // Channel Number
+#define FSCTRL1 0x0B  // Frequency Synthesizer Control
+#define FSCTRL0 0x0C  // Frequency Synthesizer Control
+#define FREQ2 0x0D    // Frequency Control Word, High Byte
+#define FREQ1 0x0E    // Frequency Control Word, Middle Byte
+#define FREQ0 0x0F    // Frequency Control Word, Low Byte
+#define MDMCFG4 0x10  // Modem Configuration
+#define MDMCFG3 0x11  // Modem Configuration
+#define MDMCFG2 0x12  // Modem Configuration
+#define MDMCFG1 0x13  // Modem Configuration
+#define MDMCFG0 0x14  // Modem Configuration
+#define DEVIATN 0x15  // Modem Deviation Setting
+#define MCSM2 0x16    // Main Radio Control State Machine Configuration
+#define MCSM1 0x17    // Main Radio Control State Machine Configuration
+#define MCSM0 0x18    // Main Radio Control State Machine Configuration
+#define FOCCFG 0x19   // Frequency Offset Compensation Configuration
+#define BSCFG 0x1A    // Bit Synchronization Configuration
+#define AGCCTRL2 0x1B // AGC Control
+#define AGCCTRL1 0x1C // AGC Control
+#define AGCCTRL0 0x1D // AGC Control
+#define WOREVT1 0x1E  // High Byte Event0 Timeout
+#define WOREVT0 0x1F  // Low Byte Event0 Timeout
+#define WORCTRL 0x20  // Wake On Radio Control
+#define FREND1 0x21   // Front End RX Configuration
+#define FREND0 0x22   // Front End TX Configuration
+#define FSCAL3 0x23   // Frequency Synthesizer Calibration
+#define FSCAL2 0x24   // Frequency Synthesizer Calibration
+#define FSCAL1 0x25   // Frequency Synthesizer Calibration
+#define FSCAL0 0x26   // Frequency Synthesizer Calibration
+#define RCCTRL1 0x27  // RC Oscillator Configuration
+#define RCCTRL0 0x28  // RC Oscillator Configuration
+#define FSTEST 0x29   // Frequency Synthesizer Calibration Control
+#define PTEST 0x2A    // Production Test
+#define AGCTEST 0x2B  // AGC Test
+#define TEST2 0x2C    // Various Test Settings
+#define TEST1 0x2D    // Various Test Settings
+#define TEST0 0x2E    // Various Test Settings
 
 // Command strobes - CC1101 Datasheet Table 42
-#define SRES      0x30
-#define SFSTXON   0x31
-#define SXOFF     0x32
-#define SCAL      0x33
-#define SRX       0x34
-#define STX       0x35
-#define SIDLE     0x36
-#define SAFC      0x37
-#define SWOR      0x38
-#define SPWD      0x39
-#define SFRX      0x3A
-#define SFTX      0x3B
-#define SWORRST   0x3C
-#define SNOP      0x3D
+#define SRES 0x30
+#define SFSTXON 0x31
+#define SXOFF 0x32
+#define SCAL 0x33
+#define SRX 0x34
+#define STX 0x35
+#define SIDLE 0x36
+#define SAFC 0x37
+#define SWOR 0x38
+#define SPWD 0x39
+#define SFRX 0x3A
+#define SFTX 0x3B
+#define SWORRST 0x3C
+#define SNOP 0x3D
 
 // Status Registers - CC1101 Datasheet Table 44
-#define PARTNUM         0x30
-#define VERSION         0x31
-#define FREQEST         0x32
-#define LQI             0x33
-#define RSSI            0x34
-#define MARCSTATE       0x35
-#define WORTIME1        0x36
-#define WORTIME0        0x37
-#define PKTSTATUS       0x38
-#define VCO_VC_DAC      0x39
-#define TXBYTES         0x3A
-#define RXBYTES         0x3B
-#define RCCTRL1_STATUS  0x3C
-#define RCCTRL0_STATUS  0x3D
+#define PARTNUM 0x30
+#define VERSION 0x31
+#define FREQEST 0x32
+#define LQI 0x33
+#define RSSI 0x34
+#define MARCSTATE 0x35
+#define WORTIME1 0x36
+#define WORTIME0 0x37
+#define PKTSTATUS 0x38
+#define VCO_VC_DAC 0x39
+#define TXBYTES 0x3A
+#define RXBYTES 0x3B
+#define RCCTRL1_STATUS 0x3C
+#define RCCTRL0_STATUS 0x3D
 
-#define PATABLE         0x3E
-#define FIFO            0x3F
+#define PATABLE 0x3E
+#define FIFO 0x3F
 
-#define FIFO_LEN                64
+#define FIFO_LEN 64
 
 // State transition times - CC1101 Datasheet Page 54/55
-#define TIME_IDLE_TO_RX_NOCAL   76      // Rounded up from 75.1
-#define TIME_IDLE_TO_RX_CAL     799
-#define TIME_IDLE_TO_TX_NOCAL   76      // Rounded up from 75.2
-#define TIME_IDLE_TO_TX_CAL     799
-#define TIME_TX_TO_RX           32      // Rounded up from 31.1 - compensates for variable baud rate
-#define TIME_RX_TO_TX           32
-#define TIME_TX_TO_IDLE_NOCAL   1       // Rounded up from 0.25/baud - compensates for variable baud rate
-#define TIME_TX_TO_IDLE_CAL     726     // Rounded up from 725 to compensate for variable baud rate
-#define TIME_RX_TO_IDLE_NOCAL   1       // Rounded up from ~0.1 
-#define TIME_RX_TO_IDLE_CAL     724
-#define TIME_MANUAL_CAL         735
+#define TIME_IDLE_TO_RX_NOCAL 76 // Rounded up from 75.1
+#define TIME_IDLE_TO_RX_CAL 799
+#define TIME_IDLE_TO_TX_NOCAL 76 // Rounded up from 75.2
+#define TIME_IDLE_TO_TX_CAL 799
+#define TIME_TX_TO_RX 32 // Rounded up from 31.1 - compensates for variable baud rate
+#define TIME_RX_TO_TX 32
+#define TIME_TX_TO_IDLE_NOCAL 1 // Rounded up from 0.25/baud - compensates for variable baud rate
+#define TIME_TX_TO_IDLE_CAL 726 // Rounded up from 725 to compensate for variable baud rate
+#define TIME_RX_TO_IDLE_NOCAL 1 // Rounded up from ~0.1
+#define TIME_RX_TO_IDLE_CAL 724
+#define TIME_MANUAL_CAL 735
 
 // Error macros
 #ifndef CONFIG_DYNAMIC_DEBUG
 extern uint debug;
-#define CC1101_DEBUG(cc1101, format, ...)    if (debug) dev_info(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
+#define CC1101_DEBUG(cc1101, format, ...) \
+  if (debug)                              \
+  dev_info(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
 #else
-#define CC1101_DEBUG(cc1101, format, ...)    dev_dbg(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
+#define CC1101_DEBUG(cc1101, format, ...) dev_dbg(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
 #endif
 
-#define CC1101_INFO(cc1101, format, ...)     dev_info(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
-#define CC1101_ERROR(cc1101, format, ...)    dev_err(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
+#define CC1101_INFO(cc1101, format, ...) dev_info(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
+#define CC1101_ERROR(cc1101, format, ...) dev_err(&cc1101->spi->dev, format "\n", ##__VA_ARGS__)
 
 // Driver state
-typedef enum {
-    MODE_IDLE,
-    MODE_TX,
-    MODE_RX
+typedef enum
+{
+  MODE_IDLE,
+  MODE_TX,
+  MODE_RX
 } cc1101_mode_t;
 
-
 // Struct to hold per-device state
-typedef struct {
-    struct spi_device *spi;
-    dev_t devt;
-    int irq;
-    struct mutex chrdev_lock;
-    struct mutex device_lock;
-    cc1101_mode_t mode;
-    struct cc1101_tx_config tx_config;
-    struct cc1101_rx_config rx_config;
-    unsigned char *current_packet;
-    u32 bytes_remaining;
-    DECLARE_KFIFO_PTR(rx_fifo, unsigned char);
-    struct timer_list rx_timeout;
-    struct work_struct rx_timeout_work;
+typedef struct
+{
+  struct spi_device *spi;
+  dev_t devt;
+  int irq;
+  struct mutex chrdev_lock;
+  struct mutex device_lock;
+  cc1101_mode_t mode;
+  struct cc1101_tx_config tx_config;
+  struct cc1101_rx_config rx_config;
+  unsigned char *current_packet;
+  u32 bytes_remaining;
+  DECLARE_KFIFO_PTR(rx_fifo, unsigned char);
+  struct timer_list rx_timeout;
+  struct work_struct rx_timeout_work;
 } cc1101_t;
 
-#endif
\ No newline at end of file
+#endif
diff --git a/cc1101_radio.c b/cc1101_radio.c
index b0c1050..4ce03c7 100755
--- a/cc1101_radio.c
+++ b/cc1101_radio.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
-* Copyright (c) 2021
-*/
+ * Copyright (c) 2021
+ */
 #include "cc1101_internal.h"
 #include "cc1101_radio.h"
 #include "cc1101_config.h"
@@ -12,314 +12,334 @@
 #include <linux/jiffies.h>
 
 /*
-*   Change the hardware and driver state. Delays based on the state transition times in the datasheet
-*
-*   Arguments:
-*   cc1101: device struct
-*   to: mode to change the device state to
-*/
-static void change_state(cc1101_t* cc1101, cc1101_mode_t to){
-
-    unsigned long delay;
-    unsigned char command;
-
-    switch(to){
-        case MODE_IDLE:
-            command = SIDLE;
-            switch(cc1101->mode) {
-                case MODE_TX:
-                    CC1101_DEBUG(cc1101, "TX -> IDLE");
-                    delay = TIME_TX_TO_IDLE_CAL;
-                    break;
-                case MODE_RX:
-                    CC1101_DEBUG(cc1101, "RX -> IDLE");
-                    delay = TIME_RX_TO_IDLE_CAL;
-                    break;
-                case MODE_IDLE:
-                    CC1101_DEBUG(cc1101, "IDLE -> IDLE");
-                    return;
-                default: 
-                    CC1101_DEBUG(cc1101, "%d -> IDLE", to);
-                    return;
-            }
-            break;
-        case MODE_TX:
-            command = STX;
-            switch(cc1101->mode) {
-                case MODE_IDLE:
-                    CC1101_DEBUG(cc1101, "IDLE -> TX");
-                    delay = TIME_IDLE_TO_TX_CAL;
-                    break;
-                case MODE_RX:
-                    CC1101_DEBUG(cc1101, "RX -> TX");
-                    delay = TIME_RX_TO_TX;
-                    break;
-                case MODE_TX:
-                    CC1101_DEBUG(cc1101, "TX -> TX");
-                    return;
-                default: 
-                    CC1101_DEBUG(cc1101, "%d -> TX", to);
-                    return;
-            }
-            break;
-        case MODE_RX:
-            command = SRX;
-            switch(cc1101->mode) {
-                case MODE_IDLE:
-                    CC1101_DEBUG(cc1101, "IDLE -> RX");
-                    delay = TIME_IDLE_TO_RX_CAL;
-                    break;
-                case MODE_TX:
-                    CC1101_DEBUG(cc1101, "TX -> RX");
-                    delay = TIME_TX_TO_RX;
-                    break;
-                case MODE_RX:
-                    CC1101_DEBUG(cc1101, "RX -> RX");
-                    return;
-                default: 
-                    CC1101_DEBUG(cc1101, "%d -> RX", to);
-                    return;
-            }
-            break;
-        default:
-            return;
+ *   Change the hardware and driver state. Delays based on the state transition times in the datasheet
+ *
+ *   Arguments:
+ *   cc1101: device struct
+ *   to: mode to change the device state to
+ */
+static void change_state(cc1101_t *cc1101, cc1101_mode_t to)
+{
+
+  unsigned long delay;
+  unsigned char command;
+
+  switch (to)
+  {
+  case MODE_IDLE:
+    command = SIDLE;
+    switch (cc1101->mode)
+    {
+    case MODE_TX:
+      CC1101_DEBUG(cc1101, "TX -> IDLE");
+      delay = TIME_TX_TO_IDLE_CAL;
+      break;
+    case MODE_RX:
+      CC1101_DEBUG(cc1101, "RX -> IDLE");
+      delay = TIME_RX_TO_IDLE_CAL;
+      break;
+    case MODE_IDLE:
+      CC1101_DEBUG(cc1101, "IDLE -> IDLE");
+      return;
+    default:
+      CC1101_DEBUG(cc1101, "%d -> IDLE", to);
+      return;
+    }
+    break;
+  case MODE_TX:
+    command = STX;
+    switch (cc1101->mode)
+    {
+    case MODE_IDLE:
+      CC1101_DEBUG(cc1101, "IDLE -> TX");
+      delay = TIME_IDLE_TO_TX_CAL;
+      break;
+    case MODE_RX:
+      CC1101_DEBUG(cc1101, "RX -> TX");
+      delay = TIME_RX_TO_TX;
+      break;
+    case MODE_TX:
+      CC1101_DEBUG(cc1101, "TX -> TX");
+      return;
+    default:
+      CC1101_DEBUG(cc1101, "%d -> TX", to);
+      return;
+    }
+    break;
+  case MODE_RX:
+    command = SRX;
+    switch (cc1101->mode)
+    {
+    case MODE_IDLE:
+      CC1101_DEBUG(cc1101, "IDLE -> RX");
+      delay = TIME_IDLE_TO_RX_CAL;
+      break;
+    case MODE_TX:
+      CC1101_DEBUG(cc1101, "TX -> RX");
+      delay = TIME_TX_TO_RX;
+      break;
+    case MODE_RX:
+      CC1101_DEBUG(cc1101, "RX -> RX");
+      return;
+    default:
+      CC1101_DEBUG(cc1101, "%d -> RX", to);
+      return;
     }
-    // Send the command via SPI
-    cc1101->mode = to;
-    cc1101_spi_send_command(cc1101, command);
-    udelay(delay);
+    break;
+  default:
+    return;
+  }
+  // Send the command via SPI
+  cc1101->mode = to;
+  cc1101_spi_send_command(cc1101, command);
+  udelay(delay);
 }
 
 /*
-* Flush the device's RXFIFO, returning to the idle state
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_flush_rx_fifo(cc1101_t *cc1101){
-    cc1101_spi_send_command(cc1101, SFRX);
-    cc1101->mode = MODE_IDLE;
+ * Flush the device's RXFIFO, returning to the idle state
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_flush_rx_fifo(cc1101_t *cc1101)
+{
+  cc1101_spi_send_command(cc1101, SFRX);
+  cc1101->mode = MODE_IDLE;
 }
 
 /*
-* Flush the device's TXFIFO, returning to the idle state
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_flush_tx_fifo(cc1101_t *cc1101){
-    cc1101_spi_send_command(cc1101, SFTX);
-    cc1101->mode = MODE_IDLE;
+ * Flush the device's TXFIFO, returning to the idle state
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_flush_tx_fifo(cc1101_t *cc1101)
+{
+  cc1101_spi_send_command(cc1101, SFTX);
+  cc1101->mode = MODE_IDLE;
 }
 
 /*
-* Set the device to idle
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_idle(cc1101_t* cc1101)
+ * Set the device to idle
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_idle(cc1101_t *cc1101)
 {
-    CC1101_DEBUG(cc1101, "Idle Mode");
-    change_state(cc1101, MODE_IDLE);
+  CC1101_DEBUG(cc1101, "Idle Mode");
+  change_state(cc1101, MODE_IDLE);
 }
 
 /*
-* Set the device to RX
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_rx(cc1101_t* cc1101)
+ * Set the device to RX
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_rx(cc1101_t *cc1101)
 {
-    CC1101_DEBUG(cc1101, "Receive Mode");
-    change_state(cc1101, MODE_RX);
+  CC1101_DEBUG(cc1101, "Receive Mode");
+  change_state(cc1101, MODE_RX);
 }
 
-# ifndef RXONLY
+#ifndef RXONLY
 /*
-* Function to transmit an arbitrary length packet (> 64 bytes)
-* Arguments:
-*   cc1101: device struct
-*   buf: bytes to transmit
-*   len: length of buf
-*
-*
-*/
-static void tx_multi(cc1101_t* cc1101, const char* buf, size_t len){
-
-    size_t bytes_remaining, fragment_size;
-    unsigned char tx_bytes;
-    int fixed_packet_mode = 0;
-
-    // Before transmission, the full packet length is left to transmit
-    bytes_remaining = len;
-
-    // Write the value that the packet counter will be at when transmission finishes into PKTLEN
-    // This is recommended by the datasheet, but will not be used until the radio
-    // is placed in fixed length packet mode 
-    cc1101_spi_write_config_register(cc1101, PKTLEN, len % 256);
-    
-    // Set to continual transmit mode
-    cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x02);
-
-    // Write the first 32 byte fragment of the packet to the device
-    cc1101_spi_write_txfifo(cc1101, &buf[0], 32);
-
-    // Decrement the number of bytes remaining to transmit
-    bytes_remaining -= 32;
-
-    // Instruct the device to begin transmission
-    change_state(cc1101, MODE_TX);
-
-    CC1101_DEBUG(cc1101, "Transmitting 32 bytes, %zu remaining, %zu Total", bytes_remaining, len);
-
-    // While there are still bytes to transmit
-    while(bytes_remaining != 0){
-
-        // Read the current number bytes in the FIFO to be transmitted
-        tx_bytes = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
-
-        // Check for underflow, exit 
-        // Caller will change state to IDLE and flush the TXFIFO, so handle the error by returning
-        if(tx_bytes > FIFO_LEN) {
-            CC1101_DEBUG(cc1101, "TXFIFO Underflow, Aborting Transmission");
-            return;
-        }
-        
-        // If there are less than 32 bytes left of the current fragment to transmit, there is room in the 
-        // device's FIFO to fit another fragment
-        if(tx_bytes < 32){
-
-            // Switch to fixed packet mode if we're safely within the last 256 bytes and haven't already
-            if(!fixed_packet_mode && bytes_remaining < 128){
-                cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x00);
-                fixed_packet_mode = 1;
-            }
-
-            // If there are less than 32 bytes left to transmit, set the number of bytes to transmit to the remaining length
-            // Otherwise, transmit a full 32 bytes
-            fragment_size = bytes_remaining < 32 ? bytes_remaining : 32;
-
-            // Write the fragment to the device's TX FIFO and decrement the number of bytes left in the packet
-            cc1101_spi_write_txfifo(cc1101, &buf[len-bytes_remaining], fragment_size);
-            bytes_remaining-=fragment_size;
-            CC1101_DEBUG(cc1101, "Transmitting %zu bytes, %zu remaining, %zu Total", fragment_size, bytes_remaining, len);
-        }
-    }
+ * Function to transmit an arbitrary length packet (> 64 bytes)
+ * Arguments:
+ *   cc1101: device struct
+ *   buf: bytes to transmit
+ *   len: length of buf
+ *
+ *
+ */
+static void tx_multi(cc1101_t *cc1101, const char *buf, size_t len)
+{
 
-    // Wait until transmission has finished
-    do {
-        bytes_remaining = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
+  size_t bytes_remaining, fragment_size;
+  unsigned char tx_bytes;
+  int fixed_packet_mode = 0;
 
-        // Check for underflow, this shouldn't occur in fixed length mode.
-        // Caller will change state to IDLE and flush the TXFIFO, so handle the error by exiting the loop
-        if(bytes_remaining > FIFO_LEN){ 
-            CC1101_DEBUG(cc1101, "TXFIFO Underflow");
-            break;
-        }
+  // Before transmission, the full packet length is left to transmit
+  bytes_remaining = len;
+
+  // Write the value that the packet counter will be at when transmission finishes into PKTLEN
+  // This is recommended by the datasheet, but will not be used until the radio
+  // is placed in fixed length packet mode
+  cc1101_spi_write_config_register(cc1101, PKTLEN, len % 256);
+
+  // Set to continual transmit mode
+  cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x02);
 
-    } while(bytes_remaining > 0);
+  // Write the first 32 byte fragment of the packet to the device
+  cc1101_spi_write_txfifo(cc1101, &buf[0], 32);
+
+  // Decrement the number of bytes remaining to transmit
+  bytes_remaining -= 32;
+
+  // Instruct the device to begin transmission
+  change_state(cc1101, MODE_TX);
+
+  CC1101_DEBUG(cc1101, "Transmitting 32 bytes, %zu remaining, %zu Total", bytes_remaining, len);
+
+  // While there are still bytes to transmit
+  while (bytes_remaining != 0)
+  {
+
+    // Read the current number bytes in the FIFO to be transmitted
+    tx_bytes = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
+
+    // Check for underflow, exit
+    // Caller will change state to IDLE and flush the TXFIFO, so handle the error by returning
+    if (tx_bytes > FIFO_LEN)
+    {
+      CC1101_DEBUG(cc1101, "TXFIFO Underflow, Aborting Transmission");
+      return;
+    }
+
+    // If there are less than 32 bytes left of the current fragment to transmit, there is room in the
+    // device's FIFO to fit another fragment
+    if (tx_bytes < 32)
+    {
+
+      // Switch to fixed packet mode if we're safely within the last 256 bytes and haven't already
+      if (!fixed_packet_mode && bytes_remaining < 128)
+      {
+        cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x00);
+        fixed_packet_mode = 1;
+      }
+
+      // If there are less than 32 bytes left to transmit, set the number of bytes to transmit to the remaining length
+      // Otherwise, transmit a full 32 bytes
+      fragment_size = bytes_remaining < 32 ? bytes_remaining : 32;
+
+      // Write the fragment to the device's TX FIFO and decrement the number of bytes left in the packet
+      cc1101_spi_write_txfifo(cc1101, &buf[len - bytes_remaining], fragment_size);
+      bytes_remaining -= fragment_size;
+      CC1101_DEBUG(cc1101, "Transmitting %zu bytes, %zu remaining, %zu Total", fragment_size, bytes_remaining, len);
+    }
+  }
+
+  // Wait until transmission has finished
+  do
+  {
+    bytes_remaining = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
+
+    // Check for underflow, this shouldn't occur in fixed length mode.
+    // Caller will change state to IDLE and flush the TXFIFO, so handle the error by exiting the loop
+    if (bytes_remaining > FIFO_LEN)
+    {
+      CC1101_DEBUG(cc1101, "TXFIFO Underflow");
+      break;
+    }
+
+  } while (bytes_remaining > 0);
 }
 
 /*
-* Function to transmit a packet that will fit completely within the CC1101's TX FIFO (<= 64 bytes)
-*
-* Arguments:
-*   cc1101: device struct
-*   buf: bytes to transmit
-*   len: length of buf
-*
-*/
-static void tx_single(cc1101_t* cc1101, const char* buf, size_t len)
+ * Function to transmit a packet that will fit completely within the CC1101's TX FIFO (<= 64 bytes)
+ *
+ * Arguments:
+ *   cc1101: device struct
+ *   buf: bytes to transmit
+ *   len: length of buf
+ *
+ */
+static void tx_single(cc1101_t *cc1101, const char *buf, size_t len)
 {
-    int bytes_remaining;
+  int bytes_remaining;
 
-    // Write the packet to device's TX FIFO
-    cc1101_spi_write_txfifo(cc1101, buf, len);
+  // Write the packet to device's TX FIFO
+  cc1101_spi_write_txfifo(cc1101, buf, len);
 
-    // Write the length of the packet to the device's Packet Length register
-    cc1101_spi_write_config_register(cc1101, PKTLEN, len);
+  // Write the length of the packet to the device's Packet Length register
+  cc1101_spi_write_config_register(cc1101, PKTLEN, len);
 
-    // Set the device's transmission mode to fixed length 
-    cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x00);
+  // Set the device's transmission mode to fixed length
+  cc1101_spi_write_config_register(cc1101, PKTCTRL0, 0x00);
 
-    // Instruct the device to begin transmission
-    change_state(cc1101, MODE_TX);
-    
-    CC1101_DEBUG(cc1101, "Transmitting %zu bytes, 0 remaining, %zu Total", len, len);
+  // Instruct the device to begin transmission
+  change_state(cc1101, MODE_TX);
 
-    // Wait until transmission has finished. Handle overflow condition
-    do {
-        bytes_remaining = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
+  CC1101_DEBUG(cc1101, "Transmitting %zu bytes, 0 remaining, %zu Total", len, len);
 
-        // Check for underflow, this shouldn't occur in fixed length mode.
-        // Handle the error by exiting the loop, as the device will be sent to idle afterwards anyway
-        if(bytes_remaining > FIFO_LEN){ 
-            CC1101_DEBUG(cc1101, "TXFIFO Underflow");
-            break;
-        }
+  // Wait until transmission has finished. Handle overflow condition
+  do
+  {
+    bytes_remaining = cc1101_spi_read_status_register(cc1101, TXBYTES).data;
 
-    } while(bytes_remaining > 0) ;
+    // Check for underflow, this shouldn't occur in fixed length mode.
+    // Handle the error by exiting the loop, as the device will be sent to idle afterwards anyway
+    if (bytes_remaining > FIFO_LEN)
+    {
+      CC1101_DEBUG(cc1101, "TXFIFO Underflow");
+      break;
+    }
+
+  } while (bytes_remaining > 0);
 }
 
 /*
-* Function to transmit a packet
-*
-* Arguments:
-*   cc1101: device struct
-*   buf: bytes to transmit
-*   len: length of buf
-*
-*/
-void cc1101_tx(cc1101_t* cc1101, const char* buf, size_t len){
-
-    CC1101_DEBUG(cc1101, "Transmit Mode");
-    // Put the device into idle mode
-    change_state(cc1101, MODE_IDLE);
-
-    // TX method based on whether the packet will fully fit in the device's FIFO
-    if(len > FIFO_LEN){
-        tx_multi(cc1101, buf, len);
-    }
-    else{
-        tx_single(cc1101, buf, len);
-    }
+ * Function to transmit a packet
+ *
+ * Arguments:
+ *   cc1101: device struct
+ *   buf: bytes to transmit
+ *   len: length of buf
+ *
+ */
+void cc1101_tx(cc1101_t *cc1101, const char *buf, size_t len)
+{
 
-    // Set the device to idle
-    cc1101_idle(cc1101);
-    
-    // Flush the TXFIFO
-    cc1101_flush_tx_fifo(cc1101);
-    
-    // Return to RX mode if configured
-    if(cc1101->rx_config.packet_length > 0){
-        // Restore RX config
-        cc1101_config_apply_rx(cc1101);
-        cc1101_rx(cc1101);
-    }
+  CC1101_DEBUG(cc1101, "Transmit Mode");
+  // Put the device into idle mode
+  change_state(cc1101, MODE_IDLE);
+
+  // TX method based on whether the packet will fully fit in the device's FIFO
+  if (len > FIFO_LEN)
+  {
+    tx_multi(cc1101, buf, len);
+  }
+  else
+  {
+    tx_single(cc1101, buf, len);
+  }
+
+  // Set the device to idle
+  cc1101_idle(cc1101);
+
+  // Flush the TXFIFO
+  cc1101_flush_tx_fifo(cc1101);
+
+  // Return to RX mode if configured
+  if (cc1101->rx_config.packet_length > 0)
+  {
+    // Restore RX config
+    cc1101_config_apply_rx(cc1101);
+    cc1101_rx(cc1101);
+  }
 }
-#endif 
+#endif
 
 /*
-* Function to reset the device and the driver's internal state
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_reset(cc1101_t* cc1101)
+ * Function to reset the device and the driver's internal state
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_reset(cc1101_t *cc1101)
 {
-    CC1101_DEBUG(cc1101, "Reset");
+  CC1101_DEBUG(cc1101, "Reset");
 
-    // Reset the device
-    cc1101->mode = MODE_IDLE;
-    cc1101_spi_send_command(cc1101, SRES);
+  // Reset the device
+  cc1101->mode = MODE_IDLE;
+  cc1101_spi_send_command(cc1101, SRES);
 
-    // Reset the current packet counter
-    cc1101->bytes_remaining = 0;
+  // Reset the current packet counter
+  cc1101->bytes_remaining = 0;
 
-    // Clear the RX FIFO
-    kfifo_reset(&cc1101->rx_fifo);
+  // Clear the RX FIFO
+  kfifo_reset(&cc1101->rx_fifo);
 }
 
 // Longest to expect between interrupts. At 0.6 kBaud (75 bytes/sec), time to fill to FIFOTHR (32 bytes) should be ~425ms, so 1000ms here seems reasonable
@@ -328,188 +348,198 @@ void cc1101_reset(cc1101_t* cc1101)
 #define RX_TIMEOUT_MS 1000
 
 /*
-* Interrupt handler function called when the device raises GDO2
-* The default receive configuration instructs it to raise GDO2 when the RX FIFO has received x bytes 
-* 
-* Arguments:
-*   irq: IRQ number
-*   handle: device struct
-*/
+ * Interrupt handler function called when the device raises GDO2
+ * The default receive configuration instructs it to raise GDO2 when the RX FIFO has received x bytes
+ *
+ * Arguments:
+ *   irq: IRQ number
+ *   handle: device struct
+ */
 irqreturn_t cc1101_rx_interrupt(int irq, void *handle)
-{   
-    cc1101_t* cc1101 = handle;
+{
+  cc1101_t *cc1101 = handle;
 
-    size_t i;
-    int fifo_available;
-    unsigned char rx_bytes;
-    
-    CC1101_DEBUG(cc1101, "Interrupt");
+  size_t i;
+  int fifo_available;
+  unsigned char rx_bytes;
 
-    // Interrupt is only used when the driver is in receive mode
-    if(cc1101->mode == MODE_RX){
+  CC1101_DEBUG(cc1101, "Interrupt");
 
-        // Stop the RX timeout timer (if it's running) while processing the interrupt
-        del_timer(&cc1101->rx_timeout);
+  // Interrupt is only used when the driver is in receive mode
+  if (cc1101->mode == MODE_RX)
+  {
 
-        // Read the number of bytes in the device's RX FIFO
-        rx_bytes = cc1101_spi_read_status_register(cc1101, RXBYTES).data;
+    // Stop the RX timeout timer (if it's running) while processing the interrupt
+    del_timer(&cc1101->rx_timeout);
 
-        // If an overflow has occured part of the packet will have been missed, so reset and wait for the next packet
-        if(rx_bytes > FIFO_LEN) {
-            CC1101_ERROR(cc1101, "RXFIFO Overflow. If this error persists, decrease baud rate");
-            
-            // Flush the RXFIFO
-            cc1101_flush_rx_fifo(cc1101);
+    // Read the number of bytes in the device's RX FIFO
+    rx_bytes = cc1101_spi_read_status_register(cc1101, RXBYTES).data;
 
-            // Reset SYNC_MODE to the value from the config
-            cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
+    // If an overflow has occured part of the packet will have been missed, so reset and wait for the next packet
+    if (rx_bytes > FIFO_LEN)
+    {
+      CC1101_ERROR(cc1101, "RXFIFO Overflow. If this error persists, decrease baud rate");
 
-            // Put the device back into receive mode ready to receive the next packet
-            change_state(cc1101, MODE_RX);
+      // Flush the RXFIFO
+      cc1101_flush_rx_fifo(cc1101);
 
-            // Unlock mutex and reset packet count
-            cc1101->bytes_remaining = 0;
-            mutex_unlock(&cc1101->device_lock);
+      // Reset SYNC_MODE to the value from the config
+      cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
 
-            return IRQ_HANDLED;
-        }
+      // Put the device back into receive mode ready to receive the next packet
+      change_state(cc1101, MODE_RX);
 
-        // If 0 bytes remaining, this is a new packet
-        if(cc1101->bytes_remaining == 0){
+      // Unlock mutex and reset packet count
+      cc1101->bytes_remaining = 0;
+      mutex_unlock(&cc1101->device_lock);
 
-            // Try to lock the device
-            if(mutex_trylock(&cc1101->device_lock) != 1){
-                // If this fails, it is because a process has /dev/cc1101.x.x open
-                CC1101_DEBUG(cc1101, "Interrupt Handler Failed To Acquire Lock");
+      return IRQ_HANDLED;
+    }
 
-                // Drain the device's RX FIFO, otherwise it will overflow, causing RX to stop
-                // This can be drained into the temp buffer as the next interrupt will start a new packet and overwrite it anyway
-                cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[0], rx_bytes - 1);
+    // If 0 bytes remaining, this is a new packet
+    if (cc1101->bytes_remaining == 0)
+    {
 
-                // Return and wait for the next interrupt  
-                return IRQ_HANDLED;
-            }
-            // If the lock is held, a packet can be received  
-            CC1101_DEBUG(cc1101, "Receiving Packet");
+      // Try to lock the device
+      if (mutex_trylock(&cc1101->device_lock) != 1)
+      {
+        // If this fails, it is because a process has /dev/cc1101.x.x open
+        CC1101_DEBUG(cc1101, "Interrupt Handler Failed To Acquire Lock");
 
-            // Update the number of bytes to receive from the RX configuration
-            cc1101->bytes_remaining = cc1101->rx_config.packet_length;
+        // Drain the device's RX FIFO, otherwise it will overflow, causing RX to stop
+        // This can be drained into the temp buffer as the next interrupt will start a new packet and overwrite it anyway
+        cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[0], rx_bytes - 1);
 
-            // Set SYNC_MODE to "No Preamble/Sync" - this will cause RX to continue even if carrier-sense drops below the defined threshold
-            // This prevents a situation where more bytes are expected for the current packet but another interrupt doesn't occur
-            cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config) & 0xF8);
+        // Return and wait for the next interrupt
+        return IRQ_HANDLED;
+      }
+      // If the lock is held, a packet can be received
+      CC1101_DEBUG(cc1101, "Receiving Packet");
 
-            // Start a timer for how long we should wait for another interrupt to arrive
-            mod_timer(&cc1101->rx_timeout, jiffies + msecs_to_jiffies(RX_TIMEOUT_MS));
-        }
+      // Update the number of bytes to receive from the RX configuration
+      cc1101->bytes_remaining = cc1101->rx_config.packet_length;
 
-        // Something went wrong and there aren't any bytes in the RX FIFO even though GDO2 went high
-        if(rx_bytes == 0){
-            // Reset the receive counter, so the next interrupt will be the start of a new packet 
-            CC1101_ERROR(cc1101, "Receive Error, Waiting for Next Packet");
-            cc1101->bytes_remaining = 0;
+      // Set SYNC_MODE to "No Preamble/Sync" - this will cause RX to continue even if carrier-sense drops below the defined threshold
+      // This prevents a situation where more bytes are expected for the current packet but another interrupt doesn't occur
+      cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config) & 0xF8);
 
-            // Reset SYNC_MODE to the value from the config
-            cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
+      // Start a timer for how long we should wait for another interrupt to arrive
+      mod_timer(&cc1101->rx_timeout, jiffies + msecs_to_jiffies(RX_TIMEOUT_MS));
+    }
 
-            // Release the device lock
-            mutex_unlock(&cc1101->device_lock);
-        }
-        // Received some bytes, but there are still some remaining in the packet to be received
-        else if(rx_bytes < cc1101->bytes_remaining){
+    // Something went wrong and there aren't any bytes in the RX FIFO even though GDO2 went high
+    if (rx_bytes == 0)
+    {
+      // Reset the receive counter, so the next interrupt will be the start of a new packet
+      CC1101_ERROR(cc1101, "Receive Error, Waiting for Next Packet");
+      cc1101->bytes_remaining = 0;
 
-            CC1101_DEBUG(cc1101, "Received %d Bytes, Read %d Bytes, %d Bytes Remaining", rx_bytes, rx_bytes - 1, cc1101->bytes_remaining - (rx_bytes - 1)); 
-            
-            // Read the received number of bytes from the device's RX FIFO into the temporary buffer
-            cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[cc1101->rx_config.packet_length - cc1101->bytes_remaining], rx_bytes - 1);
+      // Reset SYNC_MODE to the value from the config
+      cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
 
-            // Decrement the number of bytes left to receive in the packet
-            cc1101->bytes_remaining = cc1101->bytes_remaining - (rx_bytes - 1);
+      // Release the device lock
+      mutex_unlock(&cc1101->device_lock);
+    }
+    // Received some bytes, but there are still some remaining in the packet to be received
+    else if (rx_bytes < cc1101->bytes_remaining)
+    {
 
-            //  Restart the timer for how long we should wait for another interrupt to arrive
-            mod_timer(&cc1101->rx_timeout, jiffies + msecs_to_jiffies(RX_TIMEOUT_MS));
+      CC1101_DEBUG(cc1101, "Received %d Bytes, Read %d Bytes, %d Bytes Remaining", rx_bytes, rx_bytes - 1, cc1101->bytes_remaining - (rx_bytes - 1));
 
-            //Return without releasing the lock. The device is in the middle of a receive and can't be reconfigured
-        }
-        // Received a number of bytes greater than or equal to the number left in the packet 
-        else {
-            del_timer(&cc1101->rx_timeout);
+      // Read the received number of bytes from the device's RX FIFO into the temporary buffer
+      cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[cc1101->rx_config.packet_length - cc1101->bytes_remaining], rx_bytes - 1);
+
+      // Decrement the number of bytes left to receive in the packet
+      cc1101->bytes_remaining = cc1101->bytes_remaining - (rx_bytes - 1);
+
+      //  Restart the timer for how long we should wait for another interrupt to arrive
+      mod_timer(&cc1101->rx_timeout, jiffies + msecs_to_jiffies(RX_TIMEOUT_MS));
 
-            CC1101_DEBUG(cc1101, "Received %d Bytes, Read %d Bytes, %d Bytes Remaining", rx_bytes, cc1101->bytes_remaining, 0); 
+      // Return without releasing the lock. The device is in the middle of a receive and can't be reconfigured
+    }
+    // Received a number of bytes greater than or equal to the number left in the packet
+    else
+    {
+      del_timer(&cc1101->rx_timeout);
 
-            // RX has finished and the required bytes are in the device's RX FIFO, so put the device in idle mode
-            change_state(cc1101, MODE_IDLE);
+      CC1101_DEBUG(cc1101, "Received %d Bytes, Read %d Bytes, %d Bytes Remaining", rx_bytes, cc1101->bytes_remaining, 0);
 
-            // Read the remaining bytes from the device's RX FIFO
-            cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[cc1101->rx_config.packet_length - cc1101->bytes_remaining], cc1101->bytes_remaining);
+      // RX has finished and the required bytes are in the device's RX FIFO, so put the device in idle mode
+      change_state(cc1101, MODE_IDLE);
 
-            // Get the amount of space left in the received packet buffer
-            fifo_available = kfifo_avail(&cc1101->rx_fifo);
+      // Read the remaining bytes from the device's RX FIFO
+      cc1101_spi_read_rxfifo(cc1101, &cc1101->current_packet[cc1101->rx_config.packet_length - cc1101->bytes_remaining], cc1101->bytes_remaining);
 
-            // Remove oldest packet from the received packet buffer if there is less than is required to hold the newly received packet
-            if(fifo_available < cc1101->rx_config.packet_length){
-                CC1101_DEBUG(cc1101, "RX FIFO Full - Removing Packet");
-                for(i = 0; i < cc1101->rx_config.packet_length; i++){
-                    kfifo_skip(&cc1101->rx_fifo);
-                }
-            }
+      // Get the amount of space left in the received packet buffer
+      fifo_available = kfifo_avail(&cc1101->rx_fifo);
 
-            // Add the new packet to the received packet buffer
-            kfifo_in(&cc1101->rx_fifo, cc1101->current_packet, cc1101->rx_config.packet_length);
+      // Remove oldest packet from the received packet buffer if there is less than is required to hold the newly received packet
+      if (fifo_available < cc1101->rx_config.packet_length)
+      {
+        CC1101_DEBUG(cc1101, "RX FIFO Full - Removing Packet");
+        for (i = 0; i < cc1101->rx_config.packet_length; i++)
+        {
+          kfifo_skip(&cc1101->rx_fifo);
+        }
+      }
 
-            CC1101_DEBUG(cc1101, "Packet Received");
+      // Add the new packet to the received packet buffer
+      kfifo_in(&cc1101->rx_fifo, cc1101->current_packet, cc1101->rx_config.packet_length);
 
-            // Reset the number of bytes remaining
-            cc1101->bytes_remaining = 0;
+      CC1101_DEBUG(cc1101, "Packet Received");
 
-            // Flush the device's RX FIFO
-            cc1101_flush_rx_fifo(cc1101);
+      // Reset the number of bytes remaining
+      cc1101->bytes_remaining = 0;
 
-            // Reset SYNC_MODE to the value from the config
-            cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
+      // Flush the device's RX FIFO
+      cc1101_flush_rx_fifo(cc1101);
 
-            // Put the device back into receive mode ready to receive the next packet
-            change_state(cc1101, MODE_RX);
+      // Reset SYNC_MODE to the value from the config
+      cc1101_spi_write_config_register(cc1101, MDMCFG2, cc1101_get_mdmcfg2(&cc1101->rx_config.common, &cc1101->rx_config));
 
-            // Release the lock so the device can be reconfigured if necessary
-            mutex_unlock(&cc1101->device_lock);    
-        }
+      // Put the device back into receive mode ready to receive the next packet
+      change_state(cc1101, MODE_RX);
+
+      // Release the lock so the device can be reconfigured if necessary
+      mutex_unlock(&cc1101->device_lock);
     }
-    return IRQ_HANDLED;
+  }
+  return IRQ_HANDLED;
 }
 
 /*
-* Work function to recover from a missed interrupt in RX
-*
-* Arguments:
-*   work: rx_timeout_work struct of the device that has missed an interrupt 
-*/
-void cc1101_rx_timeout_work(struct work_struct *work){
-    // Get the device from the work_struct
-    cc1101_t *cc1101;
-    cc1101 = container_of(work, cc1101_t, rx_timeout_work);
-
-    // Call the interrupt handler, which will detect the RXFIFO overflow state from the device and recover
-    cc1101_rx_interrupt(cc1101->irq, cc1101);
+ * Work function to recover from a missed interrupt in RX
+ *
+ * Arguments:
+ *   work: rx_timeout_work struct of the device that has missed an interrupt
+ */
+void cc1101_rx_timeout_work(struct work_struct *work)
+{
+  // Get the device from the work_struct
+  cc1101_t *cc1101;
+  cc1101 = container_of(work, cc1101_t, rx_timeout_work);
+
+  // Call the interrupt handler, which will detect the RXFIFO overflow state from the device and recover
+  cc1101_rx_interrupt(cc1101->irq, cc1101);
 }
 
 /*
-* Receive timer callback. Called when an interrupt is expected during RX, but never arrives
-*
-* This can occur at high baud rates if the interrupt handler has not finished execution when the next interrupt arrives
-*
-* RXFIFO will have overflowed by the time this is called.
-*
-* Arguments:
-*   cc1101: device struct
-*/
-void cc1101_rx_timeout(struct timer_list *t){
-    // Get the device the timeout has occured on
-    cc1101_t *cc1101 = from_timer(cc1101, t, rx_timeout);
-    CC1101_ERROR(cc1101, "RX Interrupt Missed");
-
-    // Schedule the handler to be called in the process context to recover
-    INIT_WORK(&cc1101->rx_timeout_work, cc1101_rx_timeout_work);
-    schedule_work(&cc1101->rx_timeout_work);
-}
+ * Receive timer callback. Called when an interrupt is expected during RX, but never arrives
+ *
+ * This can occur at high baud rates if the interrupt handler has not finished execution when the next interrupt arrives
+ *
+ * RXFIFO will have overflowed by the time this is called.
+ *
+ * Arguments:
+ *   cc1101: device struct
+ */
+void cc1101_rx_timeout(struct timer_list *t)
+{
+  // Get the device the timeout has occured on
+  cc1101_t *cc1101 = from_timer(cc1101, t, rx_timeout);
+  CC1101_ERROR(cc1101, "RX Interrupt Missed");
 
+  // Schedule the handler to be called in the process context to recover
+  INIT_WORK(&cc1101->rx_timeout_work, cc1101_rx_timeout_work);
+  schedule_work(&cc1101->rx_timeout_work);
+}
