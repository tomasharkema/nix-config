diff --git a/meson.build b/meson.build
index 4cbe0a6b..5ee93a09 100644
--- a/meson.build
+++ b/meson.build
@@ -312,6 +312,7 @@ plugins_shared_reqs = {
   'sierra': true,
   'telit': true,
   'xmm': true,
+  'xmm7360': true,
   'quectel': true,
 }
 
@@ -331,7 +332,7 @@ plugins_options_reqs = {
   'cinterion': {'available': true, 'shared': []},
   'dell': {'available': true, 'shared': dell_shared_reqs},
   'dlink': {'available': true, 'shared': []},
-  'fibocom': {'available': true, 'shared': ['xmm', 'fibocom']},
+  'fibocom': {'available': true, 'shared': ['xmm', 'xmm7360', 'fibocom']},
   'foxconn': {'available': enable_mbim, 'shared': ['foxconn']},
   'generic': {'available': true, 'shared': []},
   'gosuncn': {'available': true, 'shared': []},
diff --git a/src/plugins/meson.build b/src/plugins/meson.build
index b21b5e36..401246a4 100644
--- a/src/plugins/meson.build
+++ b/src/plugins/meson.build
@@ -258,6 +258,26 @@ if plugins_shared['telit']
   }}
 endif
 
+# common xmm support
+if plugins_shared['xmm7360']
+  xmm_inc = include_directories('xmm7360')
+
+  common_c_args = '-DMM_MODULE_NAME="shared-xmm7360"'
+
+  sources = files(
+	'xmm7360/mm-plugin-xmm7360.c',
+	'xmm7360/mm-broadband-modem-xmm7360.c',
+	'xmm7360/mm-bearer-xmm7360.c',
+	'xmm7360/mm-xmm7360-rpc.c',
+  )
+
+  plugins += {'shared-xmm7360': {
+    'plugin': true,
+    # 'helper': {'sources': files('xmm/mm-modem-helpers-xmm.c'), 'include_directories': plugins_incs, 'c_args': common_c_args},
+    'module': {'sources': sources, 'include_directories': plugins_incs, 'c_args': common_c_args},
+  }}
+endif
+
 # common xmm support
 if plugins_shared['xmm']
   xmm_inc = include_directories('xmm')
diff --git a/src/plugins/xmm7360/README.md b/src/plugins/xmm7360/README.md
new file mode 100644
index 00000000..1a8ea425
--- /dev/null
+++ b/src/plugins/xmm7360/README.md
@@ -0,0 +1,23 @@
+## XMM7360 Support for ModemManager
+
+### Prerequisites:
+- `xmm7360` PCI driver loaded from [0]. This can be done e. g. by executing `sudo make load` in the checked out repository folder. One might be using some mechanism to automatically load the kernel module.
+- This ModemManager fork checked out.
+### Installation
+- Checkout this repository
+- run `./autogen.sh --prefix=/usr --with-dbus-sys-dir=/usr/share/dbus-1/system.d --without-mbim --without-qmi 'CFLAGS=-O0 -g'` I excluded `mbim` and `qmi` support to avoid the need for installing other packages. However, it might still be necessary to install several packages (like `libmm-glib`) to fulfill the dependency requirements of ModemManager.  I added flags to the C compiler for better debugging here and on my Arch system, it was neccessary to change the D-Bus systemd directory otherwise ModemManager wouldn't register at D-Bus. Feel free to adapt the parameters to your needs.
+- run `make && sudo make install`
+
+### Running
+Just make sure the `xmm7360` kernel module is loaded and then run ModemManager (for example `sudo ModemManager --debug`)
+A running NetworkManager instance should automatically detect the Modem and you should be able to create a mobile broadband connection with the specified APN for your provider. Other than the APN, I have not tried setting any other connection parameters. Afterwards, you should be able to connect with your modem.
+
+### Limitations
+- Disconnection is not implemented
+- No signal strength is shown
+- Many other bugs which are just unknown at the moment
+
+
+
+
+[0] https://github.com/xmm7360/xmm7360-pci/
diff --git a/src/plugins/xmm7360/mm-bearer-xmm7360.c b/src/plugins/xmm7360/mm-bearer-xmm7360.c
new file mode 100644
index 00000000..4fe043ca
--- /dev/null
+++ b/src/plugins/xmm7360/mm-bearer-xmm7360.c
@@ -0,0 +1,316 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2020 Marinus Enzinger <marinus@enzingerm.de>
+ */
+
+#include <arpa/inet.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-bearer-xmm7360.h"
+#include "mm-log.h"
+#include "mm-xmm7360-rpc.h"
+
+G_DEFINE_TYPE (MMBearerXmm7360, mm_bearer_xmm7360, MM_TYPE_BASE_BEARER)
+
+struct _MMBearerXmm7360Private {
+    xmm7360_ip_config ip_config;
+    xmm7360_rpc *rpc;
+    MMPort *data;
+    gchar ip[16];
+    gchar dns1[16];
+    gchar dns2[16];
+    gchar* dnsaddrs[3];
+    MMBearerIpConfig *bearer_ip_config;
+};
+
+/*****************************************************************************/
+/* Connect */
+
+static MMBearerConnectResult *
+connect_finish (MMBaseBearer *_self,
+                GAsyncResult *res,
+                GError **error)
+{
+
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static void
+convert_xmm_ip_config(MMBearerXmm7360Private *priv) {
+    MMBearerIpConfig *dst = priv->bearer_ip_config;
+    xmm7360_ip_config *src = &priv->ip_config;
+    /* we get static IPs to set */
+    mm_bearer_ip_config_set_method(dst, MM_BEARER_IP_METHOD_STATIC);
+    inet_ntop(AF_INET, &src->ip4_1, priv->ip, 16);
+    inet_ntop(AF_INET, &src->dns4_1, priv->dns1, 16);
+    inet_ntop(AF_INET, &src->dns4_2, priv->dns2, 16);
+    mm_bearer_ip_config_set_address(dst, priv->ip);
+    mm_bearer_ip_config_set_dns(dst, (const gchar**)priv->dnsaddrs);
+}
+
+static void
+_connect (MMBaseBearer *_self,
+          GCancellable *cancellable,
+          GAsyncReadyCallback callback,
+          gpointer user_data)
+{
+    MMBaseModem *modem  = NULL;
+    MMPort *data = NULL;
+    const gchar *apn;
+    gint32 status = 0;
+    GTask *task;
+    MMBearerXmm7360 *self = MM_BEARER_XMM7360 (_self);
+    xmm7360_rpc *rpc = self->priv->rpc;
+    MMBearerIpConfig *ip_config;
+    MMBearerConnectResult *connect_result;
+    
+
+    g_object_get (self,
+                  MM_BASE_BEARER_MODEM, &modem,
+                  NULL);
+    g_assert (modem);
+
+    /* Grab a data port */
+    data = mm_base_modem_get_best_data_port (modem, MM_PORT_TYPE_NET);
+    if (!data) {
+        g_task_report_new_error (
+            self,
+            callback,
+            user_data,
+            _connect,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_NOT_FOUND,
+            "No valid data port found to launch connection");
+    }
+
+    mm_dbg ("XMM7360 Bearer: data port grabbed, now trying to connect!");
+
+    /* Check whether we have an APN */
+    apn = mm_bearer_properties_get_apn (mm_base_bearer_peek_config (_self));
+
+    /**
+     * All the following RPC calls are made synchronously one after another. This should
+     * be subject to improvement (make it more robust and also asynchronous)
+     */
+
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaMsCallPsAttachApnConfigReq,
+        TRUE,
+        pack_uta_ms_call_ps_attach_apn_config_req(apn),
+        NULL
+    ) != 0) {
+        g_task_report_new_error (
+            self,
+            callback,
+            user_data,
+            _connect,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_NOT_FOUND,
+            "could not attach APN config");
+        return;
+    }
+
+    mm_dbg ("XMM7360 Bearer: after attach APN config!");
+
+    if(xmm7360_net_attach(rpc, &status) != 0) {
+        g_task_report_new_error (
+            self,
+            callback,
+            user_data,
+            _connect,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_NOT_FOUND,
+            "could not attach to net!");
+        return;
+    }
+    mm_dbg ("XMM7360 Bearer: after net attach!");
+    if(status == (gint32)0xffffffff) {
+        while(!rpc->attach_allowed) {
+            xmm7360_rpc_pump(rpc, NULL);
+        }
+        // now attach is allowed
+        if(xmm7360_net_attach(rpc, &status) != 0) {
+            g_task_report_new_error (
+                self,
+                callback,
+                user_data,
+                _connect,
+                MM_CORE_ERROR,
+                MM_CORE_ERROR_NOT_FOUND,
+                "could not attach to net");
+            return;
+        }
+        if(status == (gint32)0xffffffff) {
+            g_task_report_new_error (
+                self,
+                callback,
+                user_data,
+                _connect,
+                MM_CORE_ERROR,
+                MM_CORE_ERROR_NOT_FOUND,
+                "giving up attaching to net");
+            return;
+        }
+    }
+
+    mm_dbg ("XMM7360 Bearer: attached to net, waiting shortly before getting ip config!");
+
+    // ugly: wait 1 seconds before fetching IP config
+    sleep(1);
+
+    if(xmm7360_get_ip_and_dns(rpc, &self->priv->ip_config) != 0) {
+        g_task_report_new_error (
+            self,
+            callback,
+            user_data,
+            _connect,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_NOT_FOUND,
+            "could not get IP config!");
+        return;
+    }
+
+    mm_dbg ("XMM7360 Bearer: IP config fetched!");
+
+    if(xmm7360_establish_connection(rpc) != 0) {
+        g_task_report_new_error (
+            self,
+            callback,
+            user_data,
+            _connect,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_NOT_FOUND,
+            "error establishing connection finally!");
+        return;
+    }
+    
+    /* unref data from previous connections */
+    g_object_unref(self->priv->data);
+    g_clear_object (&self->priv->bearer_ip_config);
+    ip_config = self->priv->bearer_ip_config = mm_bearer_ip_config_new ();
+
+    convert_xmm_ip_config(self->priv);
+    self->priv->data = g_object_ref(data);
+
+    connect_result = mm_bearer_connect_result_new(self->priv->data, ip_config, NULL);
+
+    task = g_task_new (self, NULL, callback, user_data);
+    g_task_return_pointer (task, connect_result, g_object_unref);
+    g_object_unref (task);
+}
+
+/*****************************************************************************/
+/* Disconnect */
+
+static gboolean
+disconnect_finish (MMBaseBearer *self,
+                   GAsyncResult *res,
+                   GError **error)
+{
+    return g_task_propagate_boolean (G_TASK (res), error);
+}
+
+static void
+disconnect (MMBaseBearer *_self,
+            GAsyncReadyCallback callback,
+            gpointer user_data)
+{
+    GTask* task;
+    /* TODO: implement */
+    task = g_task_new (_self, NULL, callback, user_data);
+    g_task_return_boolean(task, FALSE);
+    g_object_unref (task);
+}
+
+/*****************************************************************************/
+
+static void
+report_connection_status (MMBaseBearer             *_self,
+                          MMBearerConnectionStatus  status)
+{
+    /* TODO: implement */
+
+    /* Chain up parent's report_connection_status() */
+    MM_BASE_BEARER_CLASS (mm_bearer_xmm7360_parent_class)->report_connection_status (_self, status);
+}
+
+/*****************************************************************************/
+
+MMBaseBearer *
+mm_bearer_xmm7360_new (MMBroadbandModemXmm7360 *modem,
+                   MMBearerProperties  *config, xmm7360_rpc* rpc)
+{
+    MMBaseBearer *base_bearer;
+    MMBearerXmm7360 *bearer;
+
+    /* The Xmm7360 bearer inherits from MMBaseBearer (so it's not a MMBroadbandBearer)
+     * and that means that the object is not async-initable, so we just use
+     * g_object_new() here */
+    bearer = g_object_new (MM_TYPE_BEARER_XMM7360,
+                           MM_BASE_BEARER_MODEM, modem,
+                           MM_BASE_BEARER_CONFIG, config,
+                           NULL);
+
+    bearer->priv->rpc = rpc;
+    
+    base_bearer = MM_BASE_BEARER (bearer);
+    /* Only export valid bearers */
+    mm_base_bearer_export (base_bearer);
+
+    return base_bearer;
+}
+
+static void
+mm_bearer_xmm7360_init (MMBearerXmm7360 *self)
+{
+    /* Initialize private data */
+    self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                              MM_TYPE_BEARER_XMM7360,
+                                              MMBearerXmm7360Private);
+    self->priv->dnsaddrs[0] = self->priv->dns1;
+    self->priv->dnsaddrs[1] = self->priv->dns2;
+    self->priv->dnsaddrs[2] = NULL;
+}
+
+static void
+dispose (GObject *object)
+{
+    MMBearerXmm7360 *self = MM_BEARER_XMM7360 (object);
+
+    g_object_unref(self->priv->data);
+    g_clear_object (&self->priv->bearer_ip_config);
+
+    G_OBJECT_CLASS (mm_bearer_xmm7360_parent_class)->dispose (object);
+}
+
+static void
+mm_bearer_xmm7360_class_init (MMBearerXmm7360Class *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+    MMBaseBearerClass *base_bearer_class = MM_BASE_BEARER_CLASS (klass);
+
+    g_type_class_add_private (object_class, sizeof (MMBearerXmm7360Private));
+
+    /* Virtual methods */
+    object_class->dispose = dispose;
+
+    base_bearer_class->connect = _connect;
+    base_bearer_class->connect_finish = connect_finish;
+    base_bearer_class->disconnect = disconnect;
+    base_bearer_class->disconnect_finish = disconnect_finish;
+    base_bearer_class->report_connection_status = report_connection_status;
+}
diff --git a/src/plugins/xmm7360/mm-bearer-xmm7360.h b/src/plugins/xmm7360/mm-bearer-xmm7360.h
new file mode 100644
index 00000000..b6cfac6e
--- /dev/null
+++ b/src/plugins/xmm7360/mm-bearer-xmm7360.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2020 Marinus Enzinger <marinus@enzingerm.de>
+ */
+
+#ifndef MM_BEARER_XMM7360_H
+#define MM_BEARER_XMM7360_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-base-bearer.h"
+#include "mm-broadband-modem-xmm7360.h"
+#include "mm-xmm7360-rpc.h"
+
+#define MM_TYPE_BEARER_XMM7360            (mm_bearer_xmm7360_get_type ())
+#define MM_BEARER_XMM7360(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BEARER_XMM7360, MMBearerXmm7360))
+#define MM_BEARER_XMM7360_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BEARER_XMM7360, MMBearerXmm7360Class))
+#define MM_IS_BEARER_XMM7360(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BEARER_XMM7360))
+#define MM_IS_BEARER_XMM7360_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BEARER_XMM7360))
+#define MM_BEARER_XMM7360_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BEARER_XMM7360, MMBearerXmm7360Class))
+
+typedef struct _MMBearerXmm7360 MMBearerXmm7360;
+typedef struct _MMBearerXmm7360Class MMBearerXmm7360Class;
+typedef struct _MMBearerXmm7360Private MMBearerXmm7360Private;
+
+struct _MMBearerXmm7360 {
+    MMBaseBearer parent;
+    MMBearerXmm7360Private *priv;
+};
+
+struct _MMBearerXmm7360Class {
+    MMBaseBearerClass parent;
+};
+
+GType mm_bearer_xmm7360_get_type (void);
+
+MMBaseBearer *mm_bearer_xmm7360_new (MMBroadbandModemXmm7360 *modem,
+                                 MMBearerProperties *config, xmm7360_rpc *rpc);
+
+#endif /* MM_BEARER_XMM7360_H */
diff --git a/src/plugins/xmm7360/mm-broadband-modem-xmm7360.c b/src/plugins/xmm7360/mm-broadband-modem-xmm7360.c
new file mode 100644
index 00000000..0c0d60e5
--- /dev/null
+++ b/src/plugins/xmm7360/mm-broadband-modem-xmm7360.c
@@ -0,0 +1,167 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2020 Marinus Enzinger
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ModemManager.h"
+#include "mm-log.h"
+#include "mm-iface-modem.h"
+#include "mm-broadband-modem-xmm.h"
+#include "mm-shared-xmm.h"
+#include "mm-broadband-modem-xmm7360.h"
+#include "mm-xmm7360-rpc.h"
+#include "mm-bearer-xmm7360.h"
+
+struct _MMBroadbandModemXmm7360Private {
+    xmm7360_rpc rpc;
+};
+
+static void iface_modem_init (MMIfaceModem *iface);
+
+/* XMM7360 specific bearer creation */
+void xmm7360_create_bearer (MMIfaceModem *self,
+                        MMBearerProperties *properties,
+                        GAsyncReadyCallback callback,
+                        gpointer user_data);
+MMBaseBearer * xmm7360_create_bearer_finish (MMIfaceModem *self,
+                                        GAsyncResult *res,
+                                        GError **error);
+
+G_DEFINE_TYPE_EXTENDED (MMBroadbandModemXmm7360, mm_broadband_modem_xmm7360, MM_TYPE_BROADBAND_MODEM_XMM, 0, 
+                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init))
+
+/*****************************************************************************/
+
+MMBroadbandModemXmm7360 *
+mm_broadband_modem_xmm7360_new (const gchar  *device,
+                            const gchar **drivers,
+                            const gchar  *plugin,
+                            guint16       vendor_id,
+                            guint16       product_id)
+{
+    return g_object_new (MM_TYPE_BROADBAND_MODEM_XMM7360,
+                         MM_BASE_MODEM_DEVICE,     device,
+                         MM_BASE_MODEM_DRIVERS,    drivers,
+                         MM_BASE_MODEM_PLUGIN,     plugin,
+                         MM_BASE_MODEM_VENDOR_ID,  vendor_id,
+                         MM_BASE_MODEM_PRODUCT_ID, product_id,
+                         NULL);
+}
+
+static void
+mm_broadband_modem_xmm7360_init (MMBroadbandModemXmm7360 *self)
+{
+    xmm7360_rpc* rpc;
+
+    /* Initialize private data */
+    self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                              MM_TYPE_BROADBAND_MODEM_XMM7360,
+                                              MMBroadbandModemXmm7360Private);
+
+    /* initialize modem RPC */
+    rpc = &self->priv->rpc;
+    if(xmm7360_rpc_init(rpc) != 0) {
+        mm_err ("Failed to initialize XMM7360 RPC!");
+        /* TODO: handle rpc initialization error */
+        return;
+    }
+
+    mm_dbg ("Initializing XMM7360 modem!");
+    /* lots of synchronous calls, this has to be improved for sure */
+    xmm7360_rpc_execute(rpc, UtaMsSmsInit, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsCbsInit, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsNetOpen, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsCallCsInit, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsCallPsInitialize, FALSE, NULL, NULL);
+    /* TODO: Signal reporting does not work yet, maybe use different parameters to this call? */
+    xmm7360_rpc_execute(rpc, UtaMsNetSetRadioSignalReporting, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsSsInit, FALSE, NULL, NULL);
+    xmm7360_rpc_execute(rpc, UtaMsSimOpenReq, FALSE, NULL, NULL);
+
+    if(xmm7360_do_fcc_unlock(rpc) != 0) {
+        /* TODO: handle error */
+        return;
+    }
+    if(xmm7360_uta_mode_set(rpc, 1) != 0) {
+        /* TODO: handle error */
+        return;
+    }
+
+    /* Had to do this otherwise ModemManager gets an error when issuing AT+CPIN? while loading modem capabilities */
+    while(!rpc->sim_initialized) {
+        xmm7360_rpc_pump(rpc, NULL);
+    }
+
+    mm_dbg ("Successfully initialized XMM7360 modem!");
+}
+
+static void
+iface_modem_init (MMIfaceModem *iface)
+{
+    iface->create_bearer = xmm7360_create_bearer;
+    iface->create_bearer_finish = xmm7360_create_bearer_finish;
+}
+
+static void
+dispose (GObject *object)
+{
+    MMBroadbandModemXmm7360 *self = MM_BROADBAND_MODEM_XMM7360 (object);
+
+    /* disconnect from RPC */
+    xmm7360_rpc_dispose(&self->priv->rpc);
+
+    G_OBJECT_CLASS (mm_broadband_modem_xmm7360_parent_class)->dispose (object);
+}
+
+static void
+mm_broadband_modem_xmm7360_class_init (MMBroadbandModemXmm7360Class *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+    g_type_class_add_private (object_class, sizeof (MMBroadbandModemXmm7360Private));
+
+    /* virtual methods */
+    object_class->dispose = dispose;
+}
+
+
+void xmm7360_create_bearer (MMIfaceModem *_self,
+                        MMBearerProperties *properties,
+                        GAsyncReadyCallback callback,
+                        gpointer user_data)
+{
+    MMBaseBearer *bearer;
+    GTask *task;
+    MMBroadbandModemXmm7360 *self = MM_BROADBAND_MODEM_XMM7360(_self);
+
+    bearer = mm_bearer_xmm7360_new (self, properties, &self->priv->rpc);
+
+    task = g_task_new (self, NULL, callback, user_data);
+    g_task_return_pointer (task, bearer, g_object_unref);
+    g_object_unref (task);
+}
+
+MMBaseBearer * xmm7360_create_bearer_finish (MMIfaceModem *self,
+                                        GAsyncResult *res,
+                                        GError **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
\ No newline at end of file
diff --git a/src/plugins/xmm7360/mm-broadband-modem-xmm7360.h b/src/plugins/xmm7360/mm-broadband-modem-xmm7360.h
new file mode 100644
index 00000000..5a5f4d69
--- /dev/null
+++ b/src/plugins/xmm7360/mm-broadband-modem-xmm7360.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2018 Aleksander Morgado <aleksander@aleksander.es>
+ * Copyright (C) 2020 Marinus Enzinger <marinus@enzingerm.de>
+ */
+
+#ifndef MM_BROADBAND_MODEM_XMM7360_H
+#define MM_BROADBAND_MODEM_XMM7360_H
+
+#include "mm-broadband-modem.h"
+
+#define MM_TYPE_BROADBAND_MODEM_XMM7360            (mm_broadband_modem_xmm7360_get_type ())
+#define MM_BROADBAND_MODEM_XMM7360(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_MODEM_XMM7360, MMBroadbandModemXmm7360))
+#define MM_BROADBAND_MODEM_XMM7360_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_MODEM_XMM7360, MMBroadbandModemXmm7360Class))
+#define MM_IS_BROADBAND_MODEM_XMM7360(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_MODEM_XMM7360))
+#define MM_IS_BROADBAND_MODEM_XMM7360_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_MODEM_XMM7360))
+#define MM_BROADBAND_MODEM_XMM7360_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_MODEM_XMM7360, MMBroadbandModemXmm7360Class))
+
+typedef struct _MMBroadbandModemXmm7360 MMBroadbandModemXmm7360;
+typedef struct _MMBroadbandModemXmm7360Class MMBroadbandModemXmm7360Class;
+typedef struct _MMBroadbandModemXmm7360Private MMBroadbandModemXmm7360Private;
+
+struct _MMBroadbandModemXmm7360 {
+    MMBroadbandModem parent;
+    MMBroadbandModemXmm7360Private *priv;
+};
+
+struct _MMBroadbandModemXmm7360Class {
+    MMBroadbandModemClass parent;
+};
+
+GType mm_broadband_modem_xmm7360_get_type (void);
+
+MMBroadbandModemXmm7360 *mm_broadband_modem_xmm7360_new (const gchar  *device,
+                                                 const gchar **drivers,
+                                                 const gchar  *plugin,
+                                                 guint16       vendor_id,
+                                                 guint16       product_id);
+
+#endif /* MM_BROADBAND_MODEM_XMM7360_H */
diff --git a/src/plugins/xmm7360/mm-plugin-xmm7360.c b/src/plugins/xmm7360/mm-plugin-xmm7360.c
new file mode 100644
index 00000000..d1db4658
--- /dev/null
+++ b/src/plugins/xmm7360/mm-plugin-xmm7360.c
@@ -0,0 +1,85 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2020 Marinus Enzinger
+ */
+
+#include <stdlib.h>
+#include <gmodule.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-log.h"
+#include "mm-plugin-xmm7360.h"
+#include "mm-broadband-modem.h"
+#include "mm-broadband-modem-xmm7360.h"
+
+G_DEFINE_TYPE (MMPluginXmm7360, mm_plugin_xmm7360, MM_TYPE_PLUGIN)
+
+MM_PLUGIN_DEFINE_MAJOR_VERSION
+MM_PLUGIN_DEFINE_MINOR_VERSION
+
+/*****************************************************************************/
+
+static MMBaseModem *
+create_modem (MMPlugin *self,
+              const gchar *uid,
+              const gchar **drivers,
+              guint16 vendor,
+              guint16 product,
+              GList *probes,
+              GError **error)
+{
+    return MM_BASE_MODEM (mm_broadband_modem_xmm7360_new (uid,
+                                                  drivers,
+                                                  mm_plugin_get_name (self),
+                                                  vendor,
+                                                  product));
+}
+
+/*****************************************************************************/
+
+G_MODULE_EXPORT MMPlugin *
+mm_plugin_create (void)
+{
+    //TODO: check if we need also "tty", "net" here
+    static const gchar *subsystems[] = { "tty", "net", "pci", NULL };
+    static const mm_uint16_pair products[] = {
+        { 0x8086, 0x7360 }, /* Intel XMM7360 */
+        { 0, 0 }
+    };
+    static const gchar *drivers[] = { "xmm7360", NULL };
+
+    return MM_PLUGIN (
+        g_object_new (MM_TYPE_PLUGIN_XMM7360,
+                      MM_PLUGIN_NAME,               "XMM7360",
+                      MM_PLUGIN_ALLOWED_SUBSYSTEMS, subsystems,
+                      MM_PLUGIN_ALLOWED_PRODUCT_IDS, products,
+                      MM_PLUGIN_ALLOWED_DRIVERS,    drivers,
+                      MM_PLUGIN_ALLOWED_AT,         TRUE,
+                      MM_PLUGIN_ALLOWED_XMM, TRUE,
+                      NULL));
+}
+
+static void
+mm_plugin_xmm7360_init (MMPluginXmm7360 *self)
+{
+}
+
+static void
+mm_plugin_xmm7360_class_init (MMPluginXmm7360Class *klass)
+{
+    MMPluginClass *plugin_class = MM_PLUGIN_CLASS (klass);
+
+    plugin_class->create_modem = create_modem;
+}
diff --git a/src/plugins/xmm7360/mm-plugin-xmm7360.h b/src/plugins/xmm7360/mm-plugin-xmm7360.h
new file mode 100644
index 00000000..f3549024
--- /dev/null
+++ b/src/plugins/xmm7360/mm-plugin-xmm7360.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2020 Marinus Enzinger
+ */
+
+#ifndef MM_PLUGIN_XMM7360_H
+#define MM_PLUGIN_XMM7360_H
+
+#include "mm-plugin.h"
+
+#define MM_TYPE_PLUGIN_XMM7360            (mm_plugin_xmm7360_get_type ())
+#define MM_PLUGIN_XMM7360(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_PLUGIN_XMM7360, MMPluginXmm7360))
+#define MM_PLUGIN_XMM7360_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_PLUGIN_XMM7360, MMPluginXmm7360Class))
+#define MM_IS_PLUGIN_XMM7360(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_PLUGIN_XMM7360))
+#define MM_IS_PLUGIN_XMM7360_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_PLUGIN_XMM7360))
+#define MM_PLUGIN_XMM7360_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_PLUGIN_XMM7360, MMPluginXmm7360Class))
+
+typedef struct {
+    MMPlugin parent;
+} MMPluginXmm7360;
+
+typedef struct {
+    MMPluginClass parent;
+} MMPluginXmm7360Class;
+
+GType mm_plugin_xmm7360_get_type (void);
+
+G_MODULE_EXPORT MMPlugin *mm_plugin_create (void);
+
+#endif /* MM_PLUGIN_XMM7360_H */
diff --git a/src/plugins/xmm7360/mm-xmm7360-rpc.c b/src/plugins/xmm7360/mm-xmm7360-rpc.c
new file mode 100644
index 00000000..bad3b6a6
--- /dev/null
+++ b/src/plugins/xmm7360/mm-xmm7360-rpc.c
@@ -0,0 +1,978 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2020 Marinus Enzinger
+ */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "mm-xmm7360-rpc.h"
+#include "mm-xmm7360-rpc-enums-types.h"
+
+#define MAX_READ_SIZE (131072)
+
+void _put_8(GByteArray* arr, glong val);
+void _put_u8(GByteArray* arr, gulong val);
+gint8 get_elem_size(gchar c);
+
+int xmm7360_rpc_init(xmm7360_rpc* rpc) {
+    int fd = open("/dev/xmm0/rpc", O_RDWR | O_SYNC);
+    if(fd < 0) {
+        return -1;
+    }
+    rpc->fd = fd;
+    rpc->attach_allowed = FALSE;
+    rpc->sim_initialized = FALSE;
+    return 0;
+}
+
+int xmm7360_rpc_dispose(xmm7360_rpc* rpc) {
+    int res;
+    if(rpc->fd < 0) {
+        return -1;
+    }
+    res = close(rpc->fd);
+    rpc->fd = -1;
+    return res;
+}
+
+rpc_message* xmm7360_rpc_alloc_message(void) {
+    GArray* response_arr = g_array_new(FALSE, TRUE, sizeof(rpc_arg));
+    rpc_message* msg = g_new0(rpc_message, 1);
+    msg->content = response_arr;
+    return msg;
+}
+
+void xmm7360_rpc_free_message(rpc_message* msg) {
+    if(msg != NULL) {
+        g_array_free(msg->content, TRUE);
+        g_bytes_unref(msg->body);
+        g_free(msg);
+    }
+}
+
+int xmm7360_rpc_pump(xmm7360_rpc* rpc, rpc_message** response_ptr) {
+    GByteArray* response_msg = g_byte_array_sized_new(MAX_READ_SIZE);
+    GBytes* response_msg_data;
+    rpc_message *response;
+    int read_bytes = read(rpc->fd, (void*)response_msg->data, MAX_READ_SIZE);
+    assert(read_bytes > 0);
+    response_msg->len = read_bytes;
+    response_msg_data = g_byte_array_free_to_bytes(response_msg);
+    response = xmm7360_rpc_alloc_message();
+    if(response_ptr != NULL) {
+        *response_ptr = response;
+    }
+    if(xmm7360_rpc_handle_message(rpc, response_msg_data, response) != 0) {
+        xmm7360_rpc_free_message(response);
+        return -1;
+    }
+    if(response->type == UNSOLICITED) {
+        //TODO printf unsolicited
+        xmm7360_rpc_handle_unsolicited(rpc, response);
+    }
+    
+    if(response_ptr == NULL) {
+        xmm7360_rpc_free_message(response);
+    }
+    return 0;
+}
+
+int xmm7360_rpc_execute(xmm7360_rpc* rpc, Xmm7360RpcCallIds cmd, gboolean is_async, GByteArray* body, rpc_message** res_ptr) {
+    gint32 tid, tid_word;
+    gint32 tid_word_be;
+    guint32 total_len;
+    rpc_message* pump_response;
+    int written;
+    GByteArray* header = g_byte_array_sized_new(22);
+    //default argument
+    if(body == NULL) {
+        body = g_byte_array_new();
+        asn_int4(body, 0);
+    }
+    if(is_async) {
+        tid = 0x11000101;
+    } else {
+        tid = 0;
+    }
+    tid_word = 0x11000100 | tid;
+    total_len = body->len + 16;
+    if(tid) {
+        total_len += 6;
+    }
+    g_byte_array_append(header, (guint8*)&total_len, 4);
+    asn_int4(header, total_len);
+    asn_int4(header, cmd);
+    tid_word_be = GINT32_TO_BE(tid_word);
+    g_byte_array_append(header, (guint8*)&tid_word_be, 4);
+    if(tid) {
+        asn_int4(header, tid);
+    }
+
+    assert(total_len == header->len + body->len - 4);
+    g_byte_array_append(header, body->data, body->len);
+    g_byte_array_free(body, TRUE);
+    written = write(rpc->fd, header->data, header->len);
+    if(written != (int)header->len) {
+        //TODO: write error
+        return -1;
+    }
+
+    while(TRUE) {
+        if(xmm7360_rpc_pump(rpc, &pump_response) != 0) {
+            return -1;
+        }
+        if(pump_response->type == RESPONSE) {
+            if(res_ptr == NULL) {
+                xmm7360_rpc_free_message(pump_response);
+                return 0;
+            }
+            *res_ptr = pump_response;
+            break;
+        }
+        xmm7360_rpc_free_message(pump_response);
+    }
+
+    return 0;
+}
+
+int xmm7360_rpc_handle_message(xmm7360_rpc* rpc, GBytes* message, rpc_message* res_ptr) {
+    gsize message_size;
+    gsize current_offset;
+    const guint8* data = g_bytes_get_data(message, &message_size);
+    gint32 txid;
+    rpc_arg* txid_arg;
+
+    assert(message_size > 20);
+    assert(data[4] == 0x02 && data[5] == 0x04);
+    assert(data[10] == 0x02 && data[11] == 0x04);
+
+    current_offset = 4;
+    if(*(gint32*)data != get_asn_int(message, &current_offset)) {
+        //TODO: printf("length mismatch, framing error?\n");
+        goto err;
+    }
+    res_ptr->code = get_asn_int(message, &current_offset);
+    res_ptr->body = g_bytes_new_from_bytes(message, 20, message_size - 20);
+    if(unpack_unknown(res_ptr->body, res_ptr->content) != 0) {
+        //TODO print error
+        goto err;
+    }
+    txid = GINT32_FROM_BE(*(gint32*)(data + 16));
+    res_ptr->tx_id = txid;
+    if(txid == 0x11000100) {
+        res_ptr->type = RESPONSE;
+        //TODO check if signedness leads to problems here
+    } else if((txid & 0xffffff00) == 0x11000100) {
+        if(res_ptr->code >= 2000) {
+            res_ptr->type = ASYNC_ACK;
+        } else {
+            res_ptr->type = RESPONSE;
+            //assert first element in content is txid
+            txid_arg = &g_array_index(res_ptr->content, rpc_arg, 0);
+            if(txid_arg->type != LONG || GET_RPC_INT(txid_arg) != txid) {
+                goto err;
+            }
+            g_array_remove_index(res_ptr->content, 0);
+            //jump over first six bytes (asn int of txid)
+            g_bytes_unref(res_ptr->body);
+            res_ptr->body = g_bytes_new_from_bytes(message, 26, message_size - 26);
+        }
+    } else {
+        res_ptr->type = UNSOLICITED;
+    }
+
+    g_bytes_unref(message);
+    return 0;
+
+err:
+    g_bytes_unref(message);
+    return -1;
+}
+
+int xmm7360_rpc_handle_unsolicited(xmm7360_rpc* rpc, rpc_message* message) {
+    rpc_arg* attach_argument;
+    Xmm7360RpcUnsolIds unsol_id = (Xmm7360RpcUnsolIds)message->code;
+
+
+    if(unsol_id == UtaMsNetIsAttachAllowedIndCb) {
+        if(message->content->len <= 2) {
+            //TODO: print error
+            return -1;
+        }
+        attach_argument = &g_array_index(message->content, rpc_arg, 2);
+        rpc->attach_allowed = GET_RPC_INT(attach_argument);
+    } else if(unsol_id == UtaMsSimInitIndCb) {
+        /* TODO: check for parameters */
+        rpc->sim_initialized = TRUE;
+    }
+    return 0;
+}
+
+GByteArray* pack(guint count, rpc_arg* args) {
+    GByteArray* ret = g_byte_array_new();
+    guint i;
+    gint16 sh;
+    gint32 lng;
+    for(i = 0; i < count; i++, args++) {
+        switch(args->type) {
+            case BYTE:
+                g_byte_array_append(ret, (guint8[]){ 0x02, 0x01 }, 2);
+                g_byte_array_append(ret, (guint8*)&args->value.b, 1);
+                break;
+            case SHORT:
+                sh = GINT16_TO_BE(args->value.s);
+                g_byte_array_append(ret, (guint8[]){ 0x02, 0x02 }, 2);
+                g_byte_array_append(ret, (guint8*)&sh, 2);
+                break;
+            case LONG:
+                lng = GINT32_TO_BE(args->value.l);
+                g_byte_array_append(ret, (guint8[]){ 0x02, 0x04 }, 2);
+                g_byte_array_append(ret, (guint8*)&lng, 4);
+                break;
+            case STRING:
+                pack_string(ret, (guint8*)args->value.string, args->size, args->size);
+                break;
+            default:
+                //should be unreachable
+                return NULL;
+        }
+    }
+    return ret;
+}
+
+void pack_string(GByteArray* target, guint8* data, gsize val_len, guint length) {
+    gsize cur_val_len;
+    guint8 len_first_byte;
+    guint len_first_byte_index;
+    guint i;
+    guint8 padding = 0;
+    //only support 1-byte element size
+    guint8 type = 0x55;
+    assert(length >= val_len);
+    g_byte_array_append(target, &type, 1);
+
+    if(val_len < 0x80) {
+        _put_u8(target, val_len);
+    } else {
+        len_first_byte = 0x80;
+        len_first_byte_index = target->len;
+        //write dummy first byte
+        _put_u8(target, len_first_byte);
+        cur_val_len = val_len;
+        while(cur_val_len > 0) {
+            len_first_byte++;
+            _put_u8(target, cur_val_len & 0xff);
+            cur_val_len >>= 8;
+        }
+        target->data[len_first_byte_index] = len_first_byte;
+    }
+
+    asn_int4(target, length);
+    asn_int4(target, length - val_len);
+    g_byte_array_append(target, data, val_len);
+    for(i = 0; i < length - val_len; i++) {
+        g_byte_array_append(target, &padding, 1);
+    }
+}
+
+void asn_int4(GByteArray* target, gint32 val) {
+    gint32 be = GINT32_TO_BE(val);
+    g_byte_array_append(target, (guint8*)"\x02\x04", 2);
+    g_byte_array_append(target, (guint8*)&be, 4);
+}
+
+gint get_asn_int(GBytes* bytes, gsize* current_offset) {
+    gint size;
+    gint val;
+    gsize len;
+    const guchar* data = g_bytes_get_data(bytes, &len);
+    data += *current_offset;
+    *current_offset += 2;
+    assert(len > *current_offset);
+    assert(*data++ == 2);
+    size = *data++;
+    *current_offset += size;
+    assert(len >= *current_offset);
+    val = 0;
+    do {
+        val <<= 8;
+        val |= *data++;
+    } while(--size > 0);
+
+    return val;
+}
+
+GBytes* get_string(GBytes* bytes, gsize *current_offset) {
+    GBytes *ret;
+    gsize len;
+    guchar valid;
+    gint value;
+    guchar type;
+    guchar bytelen;
+    gint count;
+    gint padding;
+    const guchar* data = g_bytes_get_data(bytes, &len);
+    data += *current_offset;
+    *current_offset += 2;
+    assert(len > *current_offset);
+    type = *data++;
+    valid = *data++;
+    value = valid;
+
+    assert(type == 0x55 || type == 0x56 || type == 0x57);
+    if(valid & 0x80) {
+        value = 0;
+        bytelen = valid & 0xf;
+        assert(bytelen <= 4);
+        *current_offset += bytelen;
+        assert(len > *current_offset);
+        for (valid = 0; valid < bytelen; valid++) {
+            value |= *data++ << (valid * 8);
+        }
+    }
+
+    //0x56 contains 2-byte chars
+    if(type == 0x56) {
+        value <<= 1;
+    //0x57 contains 4-byte chars
+    } else if(type == 0x57) {
+        value <<= 2;
+    }
+
+    count = get_asn_int(bytes, current_offset);
+    padding = get_asn_int(bytes, current_offset);
+    
+    if(count > 0) {
+        assert(count == value + padding);
+    }
+
+    *current_offset += (value + padding);
+    assert(len >= *current_offset);
+    ret = g_bytes_new_from_bytes(bytes, *current_offset - value, value);
+
+    return ret;
+}
+
+// helper functions
+void _put_8(GByteArray* arr, glong val) {
+    gint8 _val = (gint8)val;
+    g_byte_array_append(arr, (guint8*) &_val, 1);
+}
+
+void _put_u8(GByteArray* arr, gulong val) {
+    guint8 _val = (guint8)val;
+    g_byte_array_append(arr, &_val, 1);
+}
+
+gint8 get_elem_size(gchar c) {
+    switch(c) {
+        case 'B':
+            return 1;
+        case 'H':
+            return 2;
+        case 'L':
+            return 4;
+        default:
+            return -1;
+    }
+}
+
+GByteArray* pack_uta_ms_call_ps_connect_req(void) {
+    rpc_arg args[] = {
+        { .type = BYTE, .value = { .b = 0 } },
+        { .type = LONG, .value = { .l = 6 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_ms_call_ps_get_negotiated_dns_req(void) {
+    rpc_arg args[] = {
+        { .type = BYTE, .value = { .b = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_ms_call_ps_get_get_ip_addr_req(void) {
+    rpc_arg args[] = {
+        { .type = BYTE, .value = { .b = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_ms_net_attach_req(void) {
+    rpc_arg args[] = {
+        { .type = BYTE, .value = { .b = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = SHORT, .value = { .s = 0xffff } },
+        { .type = SHORT, .value = { .s = 0xffff } },
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 0 } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_rpc_ps_connect_to_datachannel_req(void) {
+    return pack(1, (rpc_arg[]) {
+        {
+            .type = STRING,
+            .size = 24, /* length of string + null byte */
+            .value = { .string = "/sioscc/PCIE/IOSM/IPS/0" }
+        },
+    });
+}
+
+GByteArray* pack_uta_sys_get_info(gint index) {
+    rpc_arg args[] = {
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = STRING, .size = 0, .value = { .string = "" } },
+        { .type = LONG, .value = { .l = index } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_mode_set(gint32 mode) {
+    rpc_arg args[] = {
+        { .type = LONG, .value = { .l = 0 } },
+        { .type = LONG, .value = { .l = 15 } },
+        { .type = LONG, .value = { .l = mode } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+GByteArray* pack_uta_ms_call_ps_attach_apn_config_req(const gchar* apn) {
+    gchar zeroes[270] = { 0 };
+    rpc_arg args[] = {
+        {  .type = BYTE, .value = { .b = 0 } },
+        {  .type = STRING, .size = 260, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 66, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 65, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 250, .value = { .string = zeroes } },
+        {  .type = BYTE, .value = { .b = 0 } },
+        {  .type = STRING, .size = 252, .value = { .string = zeroes } },
+        {  .type = SHORT, .value = { .s = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 20, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 104, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 260, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 66, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 65, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 250, .value = { .string = zeroes } },
+        {  .type = BYTE, .value = { .b = 0 } },
+        {  .type = STRING, .size = 252, .value = { .string = zeroes } },
+        {  .type = SHORT, .value = { .s = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 20, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 104, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 260, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 66, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 65, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 250, .value = { .string = zeroes } },
+        {  .type = BYTE, .value = { .b = 0 } },
+        {  .type = STRING, .size = 252, .value = { .string = zeroes } },
+        {  .type = SHORT, .value = { .s = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0x404 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 20, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 3 } },
+        {  .type = STRING, .size = 104, .value = { .string = apn } },
+        {  .type = STRING, .size = 260, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 66, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 65, .value = { .string = zeroes } },
+        {  .type = STRING, .size = 250, .value = { .string = zeroes } },
+        {  .type = BYTE, .value = { .b = 0 } },
+        {  .type = STRING, .size = 252, .value = { .string = zeroes } },
+        {  .type = SHORT, .value = { .s = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0x404 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 1 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = LONG, .value = { .l = 0 } },
+        {  .type = STRING, .size = 20, .value = { .string = zeroes } },
+        {  .type = LONG, .value = { .l = 3 } },
+        {  .type = STRING, .size = 103, .value = { .string = apn } },
+        {  .type = BYTE, .value = { .b = 3 } },
+        {  .type = LONG, .value = { .l = 0 } },
+    };
+    return pack(G_N_ELEMENTS(args), args);
+}
+
+int unpack_unknown(GBytes* message, GArray* args_array) {
+    gsize current_offset = 0;
+    gsize data_len;
+    const guint8* data;
+    GBytes* taken_string;
+    rpc_arg cur_arg = { 0 };
+    assert(message != NULL && args_array != NULL);
+    data = g_bytes_get_data(message, &data_len);
+    while(current_offset < data_len) {
+        cur_arg.size = 0;
+        switch(data[current_offset]) {
+            case 0x02:
+                cur_arg.type = LONG;
+                cur_arg.value.l = get_asn_int(message, &current_offset);
+                break;
+            case 0x55:
+            case 0x56:
+            case 0x57:
+                cur_arg.type = STRING;
+                taken_string = get_string(message, &current_offset);
+                if(taken_string == NULL) {
+                    return -1;
+                }
+                cur_arg.value.string = g_bytes_get_data(taken_string, &cur_arg.size);
+                g_bytes_unref(taken_string);
+                break;
+            default:
+                //TODO error handling
+                return -1;
+        }
+        g_array_append_val(args_array, cur_arg);
+    }
+    return 0;
+}
+
+gboolean unpack(GBytes* data, guint count, rpc_arg* args) {
+    guint i;
+    GBytes* string;
+    const guint8 *strdata;
+    gsize strlength;
+    gsize current_offset = 0;
+
+    for(i = 0; i < count; i++, args++) {
+        switch(args->type) {
+            case BYTE:
+                args->value.b = (gint8)get_asn_int(data, &current_offset);
+                break;
+            case SHORT:
+                args->value.s = (gint16)get_asn_int(data, &current_offset);
+                break;
+            case LONG:
+                args->value.l = (gint32)get_asn_int(data, &current_offset);
+                break;
+            case STRING:
+                string = get_string(data, &current_offset);
+                strdata = g_bytes_get_data(string, &strlength);
+                args->value.string = (const gchar*)strdata;
+                args->size = strlength;
+                break;
+            default:
+                //should be unreachable
+                return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+
+gboolean unpack_uta_ms_call_ps_get_neg_ip_addr_req(GBytes* data, guint32* ip1, guint32* ip2, guint32* ip3) {
+    rpc_arg* ip_arg;
+    guint32* ip_ptr;
+    rpc_arg args[] = {
+        { .type = LONG },
+        { .type = STRING },
+        { .type = LONG },
+        { .type = LONG },
+        { .type = LONG },
+        { .type = LONG },
+    };
+    if(!unpack(data, G_N_ELEMENTS(args), args)) {
+        return FALSE;
+    }
+    ip_arg = args + 1;
+    assert(ip_arg->size >= 12);
+    ip_ptr = (guint32*)ip_arg->value.string;
+    *ip1 = ip_ptr[0];
+    *ip2 = ip_ptr[1];
+    *ip3 = ip_ptr[2];
+    return TRUE;
+}
+
+gboolean unpack_uta_ms_call_ps_get_neg_dns_req(GBytes* data, guint32* ipv4_1, guint32* ipv4_2) {
+    guint i;
+    rpc_arg* dns_args;
+    rpc_arg args[] = {
+        { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = STRING }, { .type = LONG }, { .type = STRING }, { .type = LONG },
+        { .type = LONG },
+        { .type = STRING },
+        { .type = LONG },
+        { .type = LONG },
+        { .type = LONG },
+        { .type = LONG },
+    };
+    if(!unpack(data, G_N_ELEMENTS(args), args)) {
+        return FALSE;
+    }
+    *ipv4_1 = 0;
+    *ipv4_2 = 0;
+    dns_args = args + 1;
+    for(i = 0; i < 16; i += 2) {
+        // check for IPv4
+        if(dns_args[i + 1].value.l == 1) {
+            assert(dns_args[i].size >= 4);
+            if(*ipv4_1 == 0) {
+                *ipv4_1 = *((guint32*)dns_args[i].value.string);
+            } else {
+                *ipv4_2 = *((guint32*)dns_args[i].value.string);
+                return TRUE;
+            }
+        }
+    }
+    return TRUE;
+}
+
+int xmm7360_do_fcc_unlock(xmm7360_rpc* rpc) {
+    rpc_message *msg = NULL;
+    rpc_arg* arg;
+    GChecksum* checksum;
+    guchar key[] = { 0x3d, 0xf8, 0xc7, 0x19 };
+    gsize digest_len = 32;
+    guint8 digest[32] = { 0 };
+    gint32 fcc_chal;
+    GByteArray* digest_response;
+
+    if(xmm7360_rpc_execute(rpc, CsiFccLockQueryReq, TRUE, NULL, &msg) != 0) {
+        goto err;
+    }
+
+    if(msg->content->len < 3) {
+        goto err;
+    }
+    //second argument is fcc_state
+    arg = &g_array_index(msg->content, rpc_arg, 1);
+    assert(arg->type == LONG);
+    // if fcc stat is not 0 -> return
+    if(GET_RPC_INT(arg)) {
+        goto success;
+    }
+    //third argument is fcc_mode
+    arg++;
+    assert(arg->type == LONG);
+    // if fcc_mode is 0 -> return
+    if(!GET_RPC_INT(arg)) {
+        goto success;
+    }
+    xmm7360_rpc_free_message(msg);
+    msg = NULL;
+    if(xmm7360_rpc_execute(rpc, CsiFccLockGenChallengeReq, TRUE, NULL, &msg) != 0) {
+        goto err;
+    }
+    if(msg->content->len < 2) {
+        goto err;
+    }
+    arg = &g_array_index(msg->content, rpc_arg, 1);
+    assert(arg->type == LONG);
+    fcc_chal = GET_RPC_INT(arg);
+    xmm7360_rpc_free_message(msg);
+    checksum = g_checksum_new(G_CHECKSUM_SHA256);
+    g_checksum_update(checksum, (guchar*)&fcc_chal, 4);
+    g_checksum_update(checksum, key, 4);
+    g_checksum_get_digest(checksum, digest, &digest_len);
+    g_checksum_free(checksum);
+    digest_response = g_byte_array_new();
+    asn_int4(digest_response, GINT32_FROM_LE(*(gint32*)digest));
+
+    //send back digest
+    if(xmm7360_rpc_execute(rpc, CsiFccLockVerChallengeReq, TRUE, digest_response, &msg) != 0) {
+        goto err;
+    }
+    if(msg->content->len < 1) {
+        goto err;
+    }
+    arg = &g_array_index(msg->content, rpc_arg, 0);
+    assert(arg->type == LONG);
+    if(GET_RPC_INT(arg) != 1) {
+        goto err;
+    }
+
+success:
+    xmm7360_rpc_free_message(msg);
+    return 0;
+
+err:
+    xmm7360_rpc_free_message(msg);
+    return -1;
+}
+
+int xmm7360_uta_mode_set(xmm7360_rpc* rpc, gint32 mode) {
+    rpc_message *msg = NULL;
+    rpc_arg* arg;
+    GByteArray* args = pack_uta_mode_set(mode);
+    if(xmm7360_rpc_execute(rpc, UtaModeSetReq, FALSE, args, &msg) != 0) {
+        goto err;
+    }
+    if(msg->content->len < 1) {
+        goto err;
+    }
+    arg = &g_array_index(msg->content, rpc_arg, 0);
+    assert(arg->type == LONG);
+    if(GET_RPC_INT(arg) != 0) {
+        goto err;
+    }
+
+    while(TRUE) {
+        xmm7360_rpc_free_message(msg);
+        msg = NULL;
+        if(xmm7360_rpc_pump(rpc, &msg) != 0) {
+            goto err;
+        }
+        if((Xmm7360RpcUnsolIds)msg->code == UtaModeSetRspCb) {
+            if(msg->content->len < 1) {
+                goto err;
+            }
+            arg = &g_array_index(msg->content, rpc_arg, 0);
+            assert(arg->type == LONG);
+            if(GET_RPC_INT(arg) != mode) {
+                //TODO: mode set unable
+                goto err;
+            }
+            break;
+        }
+    }
+
+    xmm7360_rpc_free_message(msg);
+    return 0;
+
+err:
+    xmm7360_rpc_free_message(msg);
+    return -1;
+}
+
+int xmm7360_net_attach(xmm7360_rpc* rpc, gint32* status_ptr) {
+    rpc_message* message = NULL;
+    rpc_arg* status_arg = NULL;
+
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaMsNetAttachReq,
+        TRUE,
+        pack_uta_ms_net_attach_req(),
+        &message
+    ) != 0) {
+        return -1;
+    }
+
+    if(message->content->len < 2) {
+        xmm7360_rpc_free_message(message);
+        return -1;
+    }
+    status_arg = &g_array_index(message->content, rpc_arg, 1);
+    assert(status_arg->type == LONG);
+    *status_ptr = GET_RPC_INT(status_arg);
+    xmm7360_rpc_free_message(message);
+    return 0;
+}
+
+int xmm7360_get_ip_and_dns(xmm7360_rpc* rpc, xmm7360_ip_config* ip_config) {
+    rpc_message* message = NULL;
+    assert(ip_config != NULL);
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaMsCallPsGetNegIpAddrReq,
+        TRUE,
+        pack_uta_ms_call_ps_get_get_ip_addr_req(),
+        &message
+    ) != 0) {
+        goto err;
+    }
+
+    if(!unpack_uta_ms_call_ps_get_neg_ip_addr_req(
+        message->body,
+        &ip_config->ip4_1,
+        &ip_config->ip4_2,
+        &ip_config->ip4_3)
+    ) {
+        goto err;
+    }
+    xmm7360_rpc_free_message(message);
+    message = NULL;
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaMsCallPsGetNegotiatedDnsReq,
+        TRUE,
+        pack_uta_ms_call_ps_get_negotiated_dns_req(),
+        &message
+    ) != 0) {
+        goto err;
+    }
+    if(!unpack_uta_ms_call_ps_get_neg_dns_req(
+        message->body,
+        &ip_config->dns4_1,
+        &ip_config->dns4_2
+    )) {
+        goto err;
+    }
+    xmm7360_rpc_free_message(message);
+    return 0;
+
+err:
+    xmm7360_rpc_free_message(message);
+    return -1;
+}
+
+int xmm7360_establish_connection(xmm7360_rpc* rpc) {
+    rpc_message* ps_connect_result = NULL;
+    rpc_message* datachannel_connect_result = NULL;
+    GByteArray* connect_setup_body = g_byte_array_new();
+
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaMsCallPsConnectReq,
+        TRUE,
+        pack_uta_ms_call_ps_connect_req(),
+        &ps_connect_result
+    ) != 0) {
+        goto err;
+    }
+
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaRPCPsConnectToDatachannelReq,
+        FALSE,
+        pack_uta_rpc_ps_connect_to_datachannel_req(),
+        &datachannel_connect_result
+    ) != 0) {
+        goto err;
+    }
+
+    g_byte_array_append(
+        connect_setup_body,
+        g_bytes_get_data(ps_connect_result->body, NULL),
+        g_bytes_get_size(ps_connect_result->body) - 6
+    );
+    g_byte_array_append(
+        connect_setup_body,
+        g_bytes_get_data(datachannel_connect_result->body, NULL),
+        g_bytes_get_size(datachannel_connect_result->body)
+    );
+    asn_int4(connect_setup_body, 0);
+
+    if(xmm7360_rpc_execute(
+        rpc,
+        UtaRPCPSConnectSetupReq,
+        FALSE,
+        connect_setup_body,
+        NULL
+    ) != 0) {
+        goto err;
+    }
+    
+    xmm7360_rpc_free_message(ps_connect_result);
+    xmm7360_rpc_free_message(datachannel_connect_result);
+    return 0;
+
+err:
+    xmm7360_rpc_free_message(ps_connect_result);
+    xmm7360_rpc_free_message(datachannel_connect_result);
+    return -1;
+}
\ No newline at end of file
diff --git a/src/plugins/xmm7360/mm-xmm7360-rpc.h b/src/plugins/xmm7360/mm-xmm7360-rpc.h
new file mode 100644
index 00000000..c6f5e5e6
--- /dev/null
+++ b/src/plugins/xmm7360/mm-xmm7360-rpc.h
@@ -0,0 +1,617 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2020 Marinus Enzinger
+ */
+
+#ifndef MM_XMM7360_RPC_H
+#define MM_XMM7360_RPC_H
+
+#include <gmodule.h>
+#include <glib.h>
+
+typedef enum {
+    UtaMsSimOpenReq = 1,
+    UtaMsSimApduCmdReq = 2,
+    UtaMsSimApplicationReq = 4,
+    UtaMsSimDecodeFcp = 6,
+    UtaMsSimPbReadEntryReq = 0xD,
+    UtaMsSimGenPinReq = 0xF,
+    UtaMsSimModifyLockReq = 0x11,
+    UtaMsSimTkProactiveCommandRsp = 0x16,
+    UtaMsSimTkEnvelopeCommandReq = 0x17,
+    UtaMsSimTkTerminalProfileReadReq = 0x19,
+    UtaMsSimTkRegisterHandler = 0x1C,
+    UtaMsSimTkDeregisterHandler = 0x1D,
+    UtaMsCpsSetModeReq = 0x1F,
+    UtaMsCpsSetStackModeConfiguration = 0x20,
+    UtaMsCpsSetSimModeConfiguration = 0x21,
+    UtaMsCpsReadImei = 0x23,
+    UtaMsCallCsInit = 0x24,
+    UtaMsCbsInit = 0x25,
+    UtaMsSsInit = 0x26,
+    UtaMsSsSendUssdReq = 0x27,
+    UtaMsSsRespondUssd = 0x28,
+    UtaMsSsAbort = 0x29,
+    UtaMsSmsInit = 0x30,
+    UtaMsSmsSendReq = 0x31,
+    UtaMsSmsSetMemoryAvailableReq = 0x34,
+    UtaMsSmsIncomingSmsAck = 0x36,
+    UtaMsSmsSimMsgCountReq = 0x38,
+    UtaMsCallPsInitialize = 0x3A,
+    UtaMsCallPsObtainPdpContextId = 0x3B,
+    UtaMsCallPsReleasePdpContextId = 0x3C,
+    UtaMsCallPsDefinePrimaryReq = 0x3D,
+    UtaMsCallPsUndefinePrimaryReq = 0x3F,
+    UtaMsCallPsGetPrimaryReq = 0x41,
+    UtaMsCallPsSetAuthenticationReq = 0x43,
+    UtaMsCallPsSetDnsReq = 0x45,
+    UtaMsCallPsGetNegotiatedDnsReq = 0x47,
+    UtaMsCallPsGetNegIpAddrReq = 0x49,
+    UtaMsCallPsActivateReq = 0x4B,
+    UtaMsCallPsDeactivateReq = 0x4E,
+    UtaMsCallPsConnectReq = 0x51,
+    UtaMsNetOpen = 0x53,
+    UtaMsNetSetRadioSignalReporting = 0x54,
+    UtaMsNetSingleShotRadioSignalReportingReq = 0x55,
+    UtaMsNetAttachReq = 0x5C,
+    UtaMsNetPsAttachReq = 0x5D,
+    UtaMsNetPsDetachReq = 0x5E,
+    UtaMsNetScanReq = 0x5F,
+    UtaMsNetScanAbort = 0x60,
+    UtaMsNetPowerDownReq = 0x61,
+    UtaMsNetExtScanReq = 0x62,
+    UtaMsNetSetFdConfigReq = 0x6E,
+    UtaMsNetGetFdConfigReq = 0x71,
+    UtaMsNetConfigureNetworkModeReq = 0x73,
+    UtaMsNetRatModeStatusReq = 0x76,
+    UtaNvmRead = 0x79,
+    UtaNvmWrite = 0x7A,
+    UtaNvmWriteCommit = 0x7B,
+    UtaSysGetInfo = 0x7C,
+    UtaRPCPSConnectSetupReq = 0x7D,
+    UtaRPCPsConnectToDatachannelReq = 0x7E,
+    UtaRPCPSConnectReleaseReq = 0x7F,
+    UtaMsNetDcSetVoiceDomainPreferenceConfigReq = 0x80,
+    UtaMsCallCsSetupVoiceCallReq = 0x82,
+    UtaMsCallCsReleaseCallReq = 0x88,
+    UtaMsCallCsAcceptCallReq = 0x8D,
+    UtaMsCallCsSwapCallsReq = 0x90,
+    UtaMsCallCsHoldCallReq = 0x92,
+    UtaMsCallCsRetrieveCallReq = 0x94,
+    UtaMsCallCsSplitMptyReq = 0x96,
+    UtaMsCallCsJoinCallsReq = 0x98,
+    UtaMsCallCsTransferCallsReq = 0x9A,
+    UtaMsCallCsStartDtmfReq = 0x9C,
+    UtaMsCallCsStopDtmfReq = 0x9E,
+    UtaMsCallCsSetUus1Info = 0xA6,
+    UtaMsCallCsSetTtyDeviceMode = 0xA7,
+    UtaMsCallCsGetTtyDeviceMode = 0xA8,
+    UtaMsCallMultimediaSetupCallReq = 0xAC,
+    UtaMsCallMultimediaUpdateCallReq = 0xAD,
+    UtaMsCpsSetSimModeReq = 0xB0,
+    UtaMsSsCallForwardReq = 0xB2,
+    UtaMsSsCallWaitingReq = 0xB4,
+    UtaMsSsCallBarringReq = 0xB6,
+    UtaMsSsIdentificationReq = 0xB8,
+    UtaMsSmsSetSendMoreMessagesStatus = 0xBA,
+    UtaMsSmsDataDownloadReq = 0xBB,
+    UtaMsSmsDataDownloadAck = 0xBD,
+    UtaMsCallPsGetNegQosReq = 0xBE,
+    UtaMsCallPsGetTftReq = 0xC0,
+    UtaMsCallPsSetPcoReq = 0xC2,
+    UtaMsCallPsGetNwPcoReq = 0xC4,
+    UtaMsCallPsNwActivateAcceptReq = 0xC7,
+    UtaMsCallPsNwActivateRejectReq = 0xC9,
+    UtaMsCallPsSetDataPrefReq = 0xCD,
+    UtaMsCbsStartReq = 0xCF,
+    UtaMsCbsStopReq = 0xD0,
+    UtaMsCbsSetMsgFilter = 0xD3,
+    UtaMsCbsGetMsgFilter = 0xD4,
+    UtaMsCbsEtwsConfigReq = 0xD6,
+    UtaMsCbsEtwsStartReq = 0xD8,
+    UtaMsCbsEtwsStopReq = 0xDA,
+    UtaMsCpsNvmWrite = 0xDE,
+    UtaMsCpsNvmRead = 0xDF,
+    UtaMsNetConfigureRxDiversityDarp = 0xE0,
+    UtaMsNetLdrGetApnParameterList = 0xE2,
+    UtaMsNetTimeInfoReadReq = 0xE3,
+    UtaMsNetSetCsgConfigReq = 0xE6,
+    UtaMsNetBandStatusReq = 0xE7,
+    UtaMsNetGetExtendedRadioSignalInfoReq = 0xEC,
+    UtaMsNetDetachReq = 0xEF,
+    UtaMsNetSelectGprsClassReq = 0xF1,
+    UtaMsNetGetCsgConfigReq = 0xF3,
+    UtaMsNetCsServiceNotificationAccept = 0xF4,
+    UtaMsNetSingleShotFdReq = 0xF9,
+    UtaMsSimPbLocationReq = 0xFB,
+    UtaMsSimPbReadGasEntryReq = 0xFD,
+    UtaMsSimPbWriteEntryReq = 0xFF,
+    UtaMsSimPbGetMetaInformationReq = 0x101,
+    UtaMsSimPbUsimPbSelectReq = 0x103,
+    UtaMsSimPbGetFreeRecordsReq = 0x105,
+    UtaMsSimCreateReadBinaryApdu = 0x10A,
+    UtaMsSimCreateUpdateBinaryApdu = 0x10B,
+    UtaMsSimAnalyseReadResult = 0x10C,
+    UtaMsSimSetFdnReq = 0x10E,
+    SetApScreenState = 0x110,
+    UtaIoCtl = 0x111,
+    UtaIdcApMsgSetReq = 0x114,
+    UtaIdcApMsgGetReq = 0x115,
+    UtaIdcEnbleReq = 0x116,
+    UtaIdcCwsMsgSetReq = 0x119,
+    UtaIdcCwsMsgGetReq = 0x11A,
+    UtaIdcSubscribeIndications = 0x11C,
+    UtaIdcUnsubscribeIndications = 0x11D,
+    UtaBootPrepareShutdownReq = 0x11F,
+    UtaBootShutdownReq = 0x120,
+    UtaRfMaxTxPwrSet2g = 0x121,
+    UtaRfMaxTxPwrSet3g = 0x122,
+    UtaRfMaxTxPwrSet4g = 0x123,
+    UtaFreqInfoActivateReq = 0x128,
+    UtaFreqInfoGetFreqInfoReq = 0x129,
+    UtaFreqInfoDeactivateReq = 0x12A,
+    UtaFreqInfoRegisterIndications = 0x12B,
+    UtaFreqInfoDeregisterIndications = 0x12C,
+    UtaModeSetReq = 0x12F,
+    UtaNvmFlushSync = 0x130,
+    UtaProdRegisterGtiCallbackFunc = 0x132,
+    UtaProdGtiCmdReq = 0x133,
+    UtaCellTimeStampReq = 0x134,
+    UtaMsSsLcsInit = 0x136,
+    UtaMsSsLcsMoLocationReq = 0x137,
+    UtaMsSsLcsMtlrNotificationRsp = 0x139,
+    UtaMsCpAssistanceDataInjectReq = 0x13C,
+    UtaMsCpResetAssistanceData = 0x13D,
+    UtaMsCpPosMeasurementReq = 0x140,
+    UtaMsCpPosMeasurementAbortReq = 0x142,
+    UtaMsCpPosEnableMeasurementReport = 0x144,
+    UtaMsCpPosDisableMeasurementReport = 0x145,
+    UtaMsSimTkInit = 0x146,
+    UtaMsSimTkExecSmsPpRsp = 0x148,
+    UtaMsSimTkExecSimInitiatedCallRsp = 0x14A,
+    UtaMsSimTkExecSsUssdRsp = 0x14C,
+    UtaMsSimTkExecDtmfRsp = 0x14E,
+    UtaMsSimTkStopDtmfReq = 0x150,
+    UtaMsSimTkRefreshConfirmRsp = 0x152,
+    UtaMsSimTkRefreshFcnRsp = 0x154,
+    UtaMsSimTkControlReq = 0x155,
+    UtaMsSimTkTerminalProfileDownloadReq = 0x157,
+    UtaMs3gpp2SmsSendReq = 0x15A,
+    UtaMs3gpp2SmsSubscribeIndications = 0x15C,
+    UtaMs3gpp2SmsUnsubscribeIndications = 0x15D,
+    RpcGetRemoteVerInfo = 0x15E,
+    UtaMsMetricsRegisterHandler = 0x160,
+    UtaMsMetricsDeregisterHandler = 0x161,
+    UtaMsMetricsSetOptions = 0x162,
+    UtaMsMetricsTrigger = 0x163,
+    UtaMsEmbmsInit = 0x164,
+    UtaMsEmbmsSetServiceReq = 0x165,
+    UtaMsEmbmsMbsfnAreaConfigReq = 0x166,
+    UtaMsEmbmsSessionConfigReq = 0x167,
+    UtaMsEmbmsSetInterestedTMGIListReq = 0x168,
+    UtaMsEmbmsSetInterestedSAIFreqReq = 0x169,
+    UtaImsSubscribeIndications = 0x176,
+    UtaImsUnsubscribeIndications = 0x177,
+    UtaImsGetFrameworkState = 0x178,
+    UtaRtcGetDatetime = 0x179,
+    UtaMsSimAnalyseSimApduResult = 0x17A,
+    UtaMsSimOpenChannelReq = 0x17B,
+    UtaMsSimCloseChannelReq = 0x17D,
+    UtaMsSimSetBdnReq = 0x17F,
+    UtaMsSetSimStackMappingReq = 0x181,
+    UtaMsGetSimStackMappingReq = 0x183,
+    UtaMsNetSetRadioSignalReportingConfiguration = 0x188,
+    UtaPCIeEnumerationextTout = 0x189,
+    UtaMsSimTkSetTerminalCapabilityReq = 0x18A,
+    UtaMsSimTkReadTerminalCapabilityReq = 0x18C,
+    CsiFccLockQueryReq = 0x18E,
+    CsiFccLockGenChallengeReq = 0x190,
+    CsiFccLockVerChallengeReq = 0x192,
+    UtaSensorOpenReq = 0x194,
+    UtaSensorCloseExt = 0x197,
+    UtaSensorStartExt = 0x198,
+    UtaSensorSetAlarmParamExt = 0x199,
+    UtaSensorSetSchedulerParamExt = 0x19A,
+    CsiSioIpFilterCntrlSetReq = 0x19B,
+    UtaMsAccCurrentFreqInfoReq = 0x19D,
+    CsiTrcAtCmndReq = 0x1A0,
+    UtaMsSimApduCmdExtReq = 0x1A2,
+    UtaMsNetGetPlmnNameInfoReq = 0x1A4,
+    UtaMsNetGetCountryListReq = 0x1A7,
+    UtaMsNetExtConfigureNetworkModeReq = 0x1A9,
+    UtaMsNetExtBandStatusReq = 0x1AC,
+    UtaMsCallPsAttachApnConfigReq = 0x1AF,
+    CsiMsCallPsInitialize = 0x1B1,
+    UtaAudioEnableSource = 0x1B2,
+    UtaAudioDisableSource = 0x1B3,
+    UtaAudioConfigureDestinationExt = 0x1B4,
+    UtaAudioSetDestinationsForSource = 0x1B5,
+    UtaAudioSetVolumeForSource = 0x1B6,
+    UtaAudioSetMuteForSourceExt = 0x1B7,
+    UtaAudioSetVolumeForDestination = 0x1B8,
+    UtaAudioSetMuteForDestinationExt = 0x1B9,
+    UtaAudioConfigureSourceExt = 0x1BA,
+    UtaAudioSetDestinationsForSourceExt = 0x1BB,
+    UtaRPCScreenControlReq = 0x1BC,
+    UtaMsCallPsReadContextStatusReq = 0x1BD,
+    CsiMsSimAccessGetSimStateInfoReq = 0x1BF,
+    CsiMsNetGetRegistrationInfoReq = 0x1C1,
+    CsiSioIpFilterNewCntrlSetReq = 0x1C3,
+    CsiMsNetLdrGetApnPlmnParameterListReq = 0x1C5,
+    RPCGetAPIParamChangedBitmap = 0x1c8,
+} Xmm7360RpcCallIds;
+
+typedef enum {
+    UtaMsSimApduCmdRspCb = 0x003,
+    UtaMsSimApplicationRspCb = 0x005,
+    UtaMsSimInfoIndCb = 0x007,
+    UtaMsSimInitIndCb = 0x008,
+    UtaMsSimFullAccessIndCb = 0x009,
+    UtaMsSimErrorIndCb = 0x00a,
+    UtaMsSimCardIndCb = 0x00b,
+    UtaMsSimApplicationIndCb = 0x00c,
+    UtaMsSimPbReadEntryRspCb = 0x00e,
+    UtaMsSimGenPinRspCb = 0x010,
+    UtaMsSimModifyLockRspCb = 0x012,
+    UtaMsSimLockStatusIndCb = 0x013,
+    UtaMsSimTkMoSmsControlInfoIndCb = 0x014,
+    UtaMsSimTkProactiveCommandIndCb = 0x015,
+    UtaMsSimTkEnvelopeResIndCb = 0x018,
+    UtaMsSimTkTerminalProfileReadRspCb = 0x01a,
+    UtaSimTkProactiveCommandHandlerFunc = 0x01b,
+    UtaMsCpsSetModeRsp = 0x01e,
+    UtaMsCpsSetModeIndCb = 0x022,
+    UtaMsSsNetworkErrorIndCb = 0x02a,
+    UtaMsSsNetworkRejectIndCb = 0x02b,
+    UtaMsSsNetworkGsmCauseIndCb = 0x02c,
+    UtaMsSsUssdRspCb = 0x02d,
+    UtaMsSsUssdIndCb = 0x02e,
+    UtaMsSsEndIndCb = 0x02f,
+    UtaMsSmsIncomingIndCb = 0x032,
+    UtaMsSmsSendRspCb = 0x033,
+    UtaMsSmsSetMemoryAvailableRspCb = 0x035,
+    UtaMsSmsSimMsgCacheFinishedIndCb = 0x037,
+    UtaMsSmsSimMsgCountRspCb = 0x039,
+    UtaMsCallPsDefinePrimaryRspCb = 0x03e,
+    UtaMsCallPsUndefinePrimaryRspCb = 0x040,
+    UtaMsCallPsGetPrimaryRspCb = 0x042,
+    UtaMsCallPsSetAuthenticationRspCb = 0x044,
+    UtaMsCallPsSetDnsRspCb = 0x046,
+    UtaMsCallPsGetNegotiatedDnsRspCb = 0x048,
+    UtaMsCallPsGetNegIpAddrRspCb = 0x04a,
+    UtaMsCallPsActivateRspCb = 0x04c,
+    UtaMsCallPsActivateStatusIndCb = 0x04d,
+    UtaMsCallPsDeactivateRspCb = 0x04f,
+    UtaMsCallPsDeactivateIndCb = 0x050,
+    UtaMsCallPsConnectRspCb = 0x052,
+    UtaMsNetSingleShotRadioSignalReportingRspCb = 0x056,
+    UtaMsNetCellInfoIndCb = 0x057,
+    UtaMsNetConnectionInfoIndCb = 0x058,
+    UtaMsNetHspaInfoIndCb = 0x059,
+    UtaMsNetRadioSignalIndCb = 0x05a,
+    UtaMsNetCellChangeIndCb = 0x05b,
+    UtaMsNetAttachRspCb = 0x063,
+    UtaMsNetPsAttachRspCb = 0x064,
+    UtaMsNetPsDetachRspCb = 0x065,
+    UtaMsNetScanRspCb = 0x066,
+    UtaMsNetPowerDownRspCb = 0x067,
+    UtaMsNetExtScanRspCb = 0x068,
+    UtaMsNetPsAttachIndCb = 0x069,
+    UtaMsNetPsDetachIndCb = 0x06a,
+    UtaMsNetRegistrationInfoIndCb = 0x06b,
+    UtaMsNetIsAttachAllowedIndCb = 0x06c,
+    UtaMsNetGprsClassIndCb = 0x06d,
+    UtaMsNetSetFdConfigRspCb = 0x06f,
+    UtaMsNetFdConfigIndCb = 0x070,
+    UtaMsNetGetFdConfigRspCb = 0x072,
+    UtaMsNetConfigureNetworkModeRspCb = 0x074,
+    UtaMsNetNetworkModeChangeIndCb = 0x075,
+    UtaMsNetRatModeStatusRspCb = 0x077,
+    UtaMsNetRatModeStatusIndCb = 0x078,
+    UtaMsNetDcSetVoiceDomainPreferenceConfigRspCb = 0x081,
+    UtaMsCallCsSetupCallRspCb = 0x083,
+    UtaMsCallCsDialingIndCb = 0x084,
+    UtaMsCallCsAlertingIndCb = 0x085,
+    UtaMsCallCsCtmInfoIndCb = 0x086,
+    UtaMsCallCsConnectedIndCb = 0x087,
+    UtaMsCallCsReleaseCallRspCb = 0x089,
+    UtaMsCallCsDisconnectingIndCb = 0x08a,
+    UtaMsCallCsDisconnectedIndCb = 0x08b,
+    UtaMsCallCsIncomingCallIndCb = 0x08c,
+    UtaMsCallCsAcceptCallRspCb = 0x08e,
+    UtaMsCallCsProgressIndCb = 0x08f,
+    UtaMsCallCsSwapCallsRspCb = 0x091,
+    UtaMsCallCsHoldCallRspCb = 0x093,
+    UtaMsCallCsRetrieveCallRspCb = 0x095,
+    UtaMsCallCsSplitMptyRspCb = 0x097,
+    UtaMsCallCsJoinCallsRspCb = 0x099,
+    UtaMsCallCsTransferCallsRspCb = 0x09b,
+    UtaMsCallCsStartDtmfRspCb = 0x09d,
+    UtaMsCallCsStopDtmfRspCb = 0x09f,
+    UtaMsCallCsStopDtmfExtRspCb = 0x0a0,
+    UtaMsCallCsNotificationIndCb = 0x0a1,
+    UtaMsCallCsCugInfoIndCb = 0x0a2,
+    UtaMsCallCsCallingNameInfoIndCb = 0x0a3,
+    UtaMsCallCsEmergencyNumberListIndCb = 0x0a4,
+    UtaMsCallCsCallStatusIndCb = 0x0a5,
+    UtaCallMultimediaGetMediaProfilesInfoRspCb = 0x0a9,
+    UtaMsCallMultimediaSetupCallRspCb = 0x0aa,
+    UtaMsCallMultimediaUpdateCallRspCb = 0x0ab,
+    UtaMsCallCsVoimsSrvccHoStatusIndCb = 0x0ae,
+    UtaMsCpsSetSimModeRsp = 0x0af,
+    UtaMsCpsStartupIndCb = 0x0b1,
+    UtaMsSsCallForwardRspCb = 0x0b3,
+    UtaMsSsCallWaitingRspCb = 0x0b5,
+    UtaMsSsCallBarringRspCb = 0x0b7,
+    UtaMsSsIdentificationRspCb = 0x0b9,
+    UtaMsSmsDataDownloadRspCb = 0x0bc,
+    UtaMsCallPsGetNegQosRspCb = 0x0bf,
+    UtaMsCallPsGetTftRspCb = 0x0c1,
+    UtaMsCallPsSetPcoRspCb = 0x0c3,
+    UtaMsCallPsGetNwPcoRspCb = 0x0c5,
+    UtaMsCallPsNwActivateIndCb = 0x0c6,
+    UtaMsCallPsNwActivateAcceptRspCb = 0x0c8,
+    UtaMsCallPsModifyIndCb = 0x0ca,
+    UtaMsCallPsSuspendIndCb = 0x0cb,
+    UtaMsCallPsResumeIndCb = 0x0cc,
+    UtaMsCallPsSetDataPrefRspCb = 0x0ce,
+    UtaMsCbsStartRspCb = 0x0d1,
+    UtaMsCbsStopRspCb = 0x0d2,
+    UtaMsCbsNewMessageIndCb = 0x0d5,
+    UtaMsCbsEtwsConfigRspCb = 0x0d7,
+    UtaMsCbsEtwsStartRspCb = 0x0d9,
+    UtaMsCbsEtwsStopRspCb = 0x0db,
+    UtaMsCbsEtwsNotifyPrimaryWarningInd = 0x0dc,
+    UtaMsCbsEtwsNotifySecondaryWarningInd = 0x0dd,
+    UtaMsNetConfigureRxDiversityDarpIndCb = 0x0e1,
+    UtaMsNetTimeInfoReadRspCb = 0x0e4,
+    UtaMsNetTimeInfoIndCb = 0x0e5,
+    UtaMsNetBandStatusRspCb = 0x0e8,
+    UtaMsNetBandStatusIndCb = 0x0e9,
+    UtaMsNetSetCsgConfigRspCb = 0x0ea,
+    UtaMsNetGetCsgConfigRspCb = 0x0eb,
+    UtaMsNetGetExtendedRadioSignalInfoRspCb = 0x0ed,
+    UtaMsNetNitzInfoIndCb = 0x0ee,
+    UtaMsNetDetachRspCb = 0x0f0,
+    UtaMsNetSelectGprsClassRspCb = 0x0f2,
+    UtaMsNetNetworkFeatureSupportInfoIndCb = 0x0f5,
+    UtaMsNetEpsNetworkFeatureSupportInfoIndCb = 0x0f6,
+    UtaMsNetCsServiceNotificationIndCb = 0x0f7,
+    UtaMsNetDualSimServiceIndCb = 0x0f8,
+    UtaMsNetSingleShotFdRspCb = 0x0fa,
+    UtaMsSimPbGetLocationRspCb = 0x0fc,
+    UtaMsSimPbReadGasEntryRspCb = 0x0fe,
+    UtaMsSimPbWriteEntryRspCb = 0x100,
+    UtaMsSimPbGetMetaInformationRspCb = 0x102,
+    UtaMsSimPbUsimPbSelectRspCb = 0x104,
+    UtaMsSimPbGetFreeRecordsRspCb = 0x106,
+    UtaMsSimPbUsimPbReadyIndCb = 0x107,
+    UtaMsSimPbCacheLoadFinishedIndCb = 0x108,
+    UtaMsSimPbCacheLoadIndCb = 0x109,
+    UtaMsSimGenPinIndCb = 0x10d,
+    UtaMsSimFdnStateIndCb = 0x10f,
+    UtaIdcApMsgSetRspCb = 0x112,
+    UtaIdcApMsgGetRspCb = 0x113,
+    UtaIdcCwsMsgSetRspCb = 0x117,
+    UtaIdcCwsMsgGetRspCb = 0x118,
+    UtaIdcCwsMsgIndCb = 0x11b,
+    UtaBootPrepareShutdownRspCb = 0x11e,
+    UtaFreqInfoActivateRspCb = 0x124,
+    UtaFreqInfoDeactivateRspCb = 0x125,
+    UtaFreqInfoGetFreqInfoRspCb = 0x126,
+    UtaFreqInfoIndicationCb = 0x127,
+    UtaModeSetRspCb = 0x12d,
+    UtaModeStartupIndCb = 0x12e,
+    UtaProdGtiCmdRspCb = 0x131,
+    UtaCellTimeStampRspCb = 0x135,
+    UtaMsSsLcsMoLocationRspCb = 0x138,
+    UtaMsSsLcsCapabilitiesIndCb = 0x13a,
+    UtaMsCpAssistanceDataInjectRspCb = 0x13b,
+    UtaMsCpAssistanceDataNeededIndCb = 0x13e,
+    UtaMsCpPosMeasurementRspCb = 0x13f,
+    UtaMsCpPosMeasurementAbortRspCb = 0x141,
+    UtaMsCpPosReportMeasurementIndCb = 0x143,
+    UtaMsSimTkExecSmsPpIndCb = 0x147,
+    UtaMsSimTkExecSimInitiatedCallIndCb = 0x149,
+    UtaMsSimTkExecSsUssdIndCb = 0x14b,
+    UtaMsSimTkExecDtmfIndCb = 0x14d,
+    UtaMsSimTkExecDtmfEndIndCb = 0x14f,
+    UtaMsSimTkRefreshConfirmIndCb = 0x151,
+    UtaMsSimTkRefreshFcnIndCb = 0x153,
+    UtaMsSimTkControlRspCb = 0x156,
+    UtaMsSimTkTerminalProfileDownloadRspCb = 0x158,
+    UtaMs3gpp2SmsSendRspCb = 0x159,
+    UtaMs3gpp2SmsIncomingIndCb = 0x15b,
+    UtaMetricsHandlerFunction = 0x15f,
+    UtaMsEmbmsSetServiceRspCb = 0x16a,
+    UtaMsEmbmsMbsfnAreaConfigRspCb = 0x16b,
+    UtaMsEmbmsSessionConfigRspCb = 0x16c,
+    UtaMsEmbmsSetInterestedTMGIListRspCb = 0x16d,
+    UtaMsEmbmsSetInterestedSAIFreqRspCb = 0x16e,
+    UtaMsEmbmsServiceIndCb = 0x16f,
+    UtaMsEmbmsMBSFNAreaIndCb = 0x170,
+    UtaMsEmbmsServicesListIndCb = 0x171,
+    UtaMsEmbmsSAIListIndCb = 0x172,
+    UtaMsEmbmsMpsInfoIndCb = 0x173,
+    UtaImsStateChangedIndCb = 0x174,
+    UtaImsServiceStateChangedIndCb = 0x175,
+    UtaMsSimOpenChannelRspCb = 0x17c,
+    UtaMsSimCloseChannelRspCb = 0x17e,
+    UtaMsSimBdnStateIndCb = 0x180,
+    UtaMsSetSimStackMappingRspCb = 0x182,
+    UtaMsGetSimStackMappingRspCb = 0x184,
+    UtaMsSimMccMncIndCb = 0x185,
+    UtaMsSimTkTerminalResponseIndCb = 0x186,
+    UtaMsNetRegisteredPlmnNameIndCb = 0x187,
+    UtaMsSimTkSetTerminalCapabilityRspCb = 0x18b,
+    UtaMsSimTkReadTerminalCapabilityRspCb = 0x18d,
+    CsiFccLockQueryRspCb = 0x18f,
+    CsiFccLockGenChallengeRspCb = 0x191,
+    CsiFccLockVerChallengeRspCb = 0x193,
+    UtaSensorOpenRspCb = 0x195,
+    UtaSensorMeasIndCb = 0x196,
+    CsiSioIpFilterCntrlSetRspCb = 0x19c,
+    CsiSioIpFilterNewCntrlSetRspCb = 0x1c4,
+    UtaMsAccCurrentFreqInfoRspCb = 0x19e,
+    UtaMsAccCurrentFreqInfoIndCb = 0x19f,
+    CsiTrcAtCmndRspCb = 0x1a1,
+    UtaMsSimApduCmdExtRspCb = 0x1a3,
+    UtaMsNetGetPlmnNameInfoRspCb = 0x1a5,
+    UtaMsNetSib8TimeInfoIndCb = 0x1a6,
+    UtaMsNetGetCountryListRspCb = 0x1a8,
+    UtaMsNetExtConfigureNetworkModeRspCb = 0x1aa,
+    UtaMsNetExtNetworkModeChangeIndCb = 0x1ab,
+    UtaMsNetExtBandStatusRspCb = 0x1ad,
+    UtaMsNetExtBandStatusIndCb = 0x1ae,
+    UtaMsCallPsAttachApnConfigRspCb = 0x1b0,
+    UtaMsCallPsReadContextStatusRspCb = 0x1be,
+    CsiMsSimAccessGetSimStateInfoRspCb = 0x1c0,
+    CsiMsNetGetRegistrationInfoRspCb = 0x1c2,
+    CsiMsNetLdrGetApnPlmnParameterListRspCb = 0x1c6,
+    UtaMsNetLdrApnParametersChangeIndCb = 0x1c7,
+} Xmm7360RpcUnsolIds;
+
+#define GET_RPC_INT(arg) (arg->type == BYTE ? arg->value.b : arg->type == SHORT ? arg->value.s : arg->type == LONG ? arg->value.l : -1)
+typedef struct {
+    enum {
+        BYTE,
+        SHORT,
+        LONG,
+        STRING
+    } type;
+    gsize size;
+    union {
+        gint8 b;
+        gint16 s;
+        gint32 l;
+        const gchar* string; 
+    } value;
+} rpc_arg;
+
+typedef struct {
+    guint32 tx_id;
+    enum {
+        RESPONSE,
+        ASYNC_ACK,
+        UNSOLICITED
+    } type;
+    guint32 code;
+    GBytes *body;
+    //contains rpc_args
+    GArray* content;
+} rpc_message;
+
+rpc_message* xmm7360_rpc_alloc_message(void);
+
+void xmm7360_rpc_free_message(rpc_message* msg);
+
+typedef struct {
+    gboolean attach_allowed;
+    gboolean sim_initialized;
+    int fd;
+} xmm7360_rpc;
+
+typedef struct {
+    guint32 ip4_1, ip4_2, ip4_3;
+    guint32 dns4_1, dns4_2;
+} xmm7360_ip_config;
+
+/**
+ * RPC Communication functions
+ */
+int xmm7360_rpc_init(xmm7360_rpc* rpc);
+
+int xmm7360_rpc_dispose(xmm7360_rpc* rpc);
+
+int xmm7360_rpc_pump(xmm7360_rpc* rpc, rpc_message** response_ptr);
+
+int xmm7360_rpc_execute(xmm7360_rpc* rpc, Xmm7360RpcCallIds cmd, gboolean is_async, GByteArray* body, rpc_message** res_ptr);
+
+int xmm7360_rpc_handle_message(xmm7360_rpc* rpc, GBytes* message, rpc_message* res_ptr);
+
+int xmm7360_rpc_handle_unsolicited(xmm7360_rpc* rpc, rpc_message* message);
+
+/**
+ * Pack a string into a byte array
+ */
+void pack_string(GByteArray* target, guint8* data, gsize val_len, guint length);
+
+/**
+ * Encode a integer
+ */
+void asn_int4(GByteArray* target, gint32 val);
+
+/**
+ * Retrieve an integer
+ */
+gint get_asn_int(GBytes* bytes, gsize* current_offset);
+
+/**
+ * Retrieve an encoded string
+ */
+GBytes* get_string(GBytes* bytes, gsize* current_offset);
+
+/**
+ * ##########################
+ * Argument packing functions
+ * ##########################
+ */
+
+GByteArray* pack(guint count, rpc_arg* args);
+
+GByteArray* pack_uta_ms_call_ps_connect_req(void);
+
+GByteArray* pack_uta_ms_call_ps_get_negotiated_dns_req(void);
+
+GByteArray* pack_uta_ms_call_ps_get_get_ip_addr_req(void);
+
+GByteArray* pack_uta_ms_net_attach_req(void);
+
+GByteArray* pack_uta_rpc_ps_connect_to_datachannel_req(void);
+
+GByteArray* pack_uta_sys_get_info(gint index);
+
+GByteArray* pack_uta_mode_set(gint32 mode);
+
+GByteArray* pack_uta_ms_call_ps_attach_apn_config_req(const gchar* apn);
+
+/**
+ * Argument unpacking functions
+ */
+
+int unpack_unknown(GBytes* data, GArray* args_array);
+
+//unpacked strings live as long as data is not freed
+gboolean unpack(GBytes* data, guint count, rpc_arg* args);
+
+gboolean unpack_uta_ms_call_ps_get_neg_ip_addr_req(GBytes* data, guint32* ip1, guint32* ip2, guint32* ip3);
+
+gboolean unpack_uta_ms_call_ps_get_neg_dns_req(GBytes* data, guint32* ipv4_1, guint32* ipv4_2);
+
+/**
+ * ###########################
+ * Complex RPC functions
+ * ###########################
+ */
+
+int xmm7360_uta_mode_set(xmm7360_rpc* rpc, gint32 mode);
+
+int xmm7360_do_fcc_unlock(xmm7360_rpc* rpc);
+
+int xmm7360_net_attach(xmm7360_rpc* rpc, gint32* status_ptr);
+
+int xmm7360_get_ip_and_dns(xmm7360_rpc* rpc, xmm7360_ip_config* ip_config);
+
+int xmm7360_establish_connection(xmm7360_rpc* rpc);
+
+#endif /* MM_XMM7360_RPC_H */
\ No newline at end of file
